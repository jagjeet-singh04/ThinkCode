[
  {
    "id": 1,
    "title": "Lily's Number Pair Hunt",
    "topic": "Array, Hash Table",
    "difficulty": "Easy",
    "description": "Lily has embarked on a magical adventure through the Enchanted Forest of Numbers, where she carries a scroll containing a list of mystical numbers. She has been given a special 'target' magic number by the Forest Guardian. Your quest is to help Lily find two distinct numbers in her list that, when combined through ancient arithmetic magic, sum up to exactly the target value. Return the indices of these two numbers, as the Forest Guardian requires their positions to unlock the next stage of her journey.",
    "constraints": [
      "2 <= numbers.length <= 10^4",
      "-10^9 <= numbers[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists"
    ],
    "examples": [
      {
        "input": "numbers = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because numbers[0] + numbers[1] == 9, we return [0, 1]."
      },
      {
        "input": "numbers = [3,4,2], target = 6",
        "output": "[1,2]",
        "explanation": "Because numbers[1] + numbers[2] == 6, we return [1, 2]."
      }
    ],
    "hint": "Original: Two Sum"
  },
  {
    "id": 2,
    "title": "Number Reverser Machine",
    "topic": "Math",
    "difficulty": "Medium",
    "description": "Tom the Tinkerer has invented a marvelous machine that can reverse the digits of any integer. However, his machine has a peculiar limitation - if reversing the number causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], the machine malfunctions and returns 0 instead. Tom needs your help to ensure his machine operates correctly. Given an integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range, return 0.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321"
      },
      {
        "input": "x = -150",
        "output": "-51"
      },
      {
        "input": "x = 1534236469",
        "output": "0",
        "explanation": "The reverse of 1534236469 is 9646324351, which is greater than 2^31 - 1 (2147483647), so we return 0."
      }
    ],
    "hint": "Original: Reverse Integer"
  },
  {
    "id": 3,
    "title": "Water Container Challenge",
    "topic": "Array, Two Pointers, Greedy",
    "difficulty": "Medium",
    "description": "You are an architect designing a revolutionary water containment system for a futuristic city. The city has n vertical walls of different heights arranged in a line. Each wall is represented by an integer array where each element represents the height of a wall. Your task is to find two walls that, together with the ground, can form a container that holds the maximum amount of water. Return the maximum amount of water that can be stored between any two walls in the system. Note: You may not slant the container.",
    "constraints": [
      "n == heights.length",
      "2 <= n <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The walls at positions 1 (height 8) and 8 (height 7) form the largest container. The area is calculated as min(8, 7) * (8-1) = 7 * 7 = 49."
      },
      {
        "input": "heights = [5,3,2,1,4]",
        "output": "16",
        "explanation": "The walls at positions 0 (height 5) and 4 (height 4) form the largest container. The area is calculated as min(5, 4) * (4-0) = 4 * 4 = 16."
      }
    ],
    "hint": "Original: Container With Most Water"
  },
  {
    "id": 4,
    "title": "Middle Value Finder",
    "topic": "Array, Binary Search, Divide and Conquer",
    "difficulty": "Hard",
    "description": "As a data analyst at a major research facility, you've been tasked with merging two sorted datasets and finding the median value of the combined dataset. The median is the middle value in an ordered integer list. If the size of the list is even, there is no single middle value, so the median is the mean of the two middle values. Implement a function that finds the median of the two sorted arrays with an overall runtime complexity of O(log (m+n)).",
    "constraints": [
      "nums1.length == m",
      "nums2.length == n",
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1,3], nums2 = [2]",
        "output": "2.00000",
        "explanation": "The merged array is [1,2,3] and the median is 2."
      },
      {
        "input": "nums1 = [1,2], nums2 = [3,4]",
        "output": "2.50000",
        "explanation": "The merged array is [1,2,3,4] and the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "hint": "Original: Median of Two Sorted Arrays"
  },
  {
    "id": 5,
    "title": "Palindrome Hunter",
    "topic": "String, Dynamic Programming",
    "difficulty": "Medium",
    "description": "You are an archaeologist deciphering ancient texts. In these texts, palindromic sequences hold special power. A palindrome is a word that reads the same forward and backward. Your mission is to find the longest palindromic substring in a given string of ancient script. This discovery could unlock secrets of a lost civilization and reveal powerful artifacts hidden for millennia.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only digits (0-9), English letters (a-z, A-Z), and no other characters"
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "\"bab\" is a valid palindrome (\"aba\" is also a valid answer)."
      },
      {
        "input": "s = \"racecar\"",
        "output": "\"racecar\"",
        "explanation": "The entire string is a palindrome."
      }
    ],
    "hint": "Original: Longest Palindromic Substring"
  },
  {
    "id": 6,
    "title": "Light Grid Controller",
    "topic": "Array, Hash Table, Matrix",
    "difficulty": "Medium",
    "description": "You are the chief engineer of a futuristic city's lighting grid system. The grid is represented by an m x n matrix. Each cell in the grid represents a smart light that can be either on (represented by 1) or off (represented by 0). Due to a newly discovered energy conservation protocol, if any light is found to be off, you must turn off all lights in its entire row and column to prevent power drainage. Your task is to modify the grid in place according to this new protocol while maintaining optimal energy efficiency.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 200",
      "-2^31 <= grid[i][j] <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "grid = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The center light is off, so its entire row and column are turned off."
      },
      {
        "input": "grid = [[0,1,2],[3,4,5]]",
        "output": "[[0,0,0],[0,4,5]]",
        "explanation": "The top-left light is off, so the first row and first column are turned off."
      }
    ],
    "hint": "Original: Set Matrix Zeros"
  },
  {
    "id": 7,
    "title": "Number Pyramid Builder",
    "topic": "Array, Dynamic Programming",
    "difficulty": "Easy",
    "description": "You are a mathematician exploring the ancient numerical pyramid patterns discovered in an archaeological dig. This special pyramid, known as Pascal's Triangle, has each number being the sum of the two numbers directly above it. The pyramid starts with a single '1' at the apex, and each subsequent row begins and ends with '1'. Your task is to reconstruct the first numRows of this mystical numerical pyramid to unlock its mathematical secrets.",
    "constraints": [
      "1 <= numRows <= 30"
    ],
    "examples": [
      {
        "input": "numRows = 5",
        "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
        "explanation": "The pyramid has 5 rows as constructed according to Pascal's Triangle rules."
      },
      {
        "input": "numRows = 3",
        "output": "[[1],[1,1],[1,2,1]]",
        "explanation": "The pyramid has 3 rows following the pattern."
      }
    ],
    "hint": "Original: Pascal's Triangle"
  },
  {
    "id": 8,
    "title": "Next Number Sequence Finder",
    "topic": "Array, Two Pointers",
    "difficulty": "Medium",
    "description": "As a cryptographer working with numerical codes, you've discovered that certain sequences have a natural ordering. Given a sequence of distinct integers, your task is to find the next permutation of numbers that is lexicographically greater than the given sequence. If no such permutation exists (meaning the sequence is already at the highest possible order), rearrange it to the lowest possible order (sorted in ascending order). You must modify the array in-place with O(1) extra memory.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[1,3,2]",
        "explanation": "The next lexicographically greater permutation of [1,2,3] is [1,3,2]."
      },
      {
        "input": "nums = [3,2,1]",
        "output": "[1,2,3]",
        "explanation": "No greater permutation exists, so return the smallest permutation."
      }
    ],
    "hint": "Original: Next Permutation"
  },
  {
    "id": 9,
    "title": "Maximum Sum Subarray Finder",
    "topic": "Array, Divide and Conquer, Dynamic Programming",
    "difficulty": "Easy",
    "description": "As a financial analyst, you're analyzing daily profit/loss data to identify the most profitable continuous period for investment. Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. This will help identify the optimal investment window for maximum returns.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum of 6."
      },
      {
        "input": "nums = [1,2,3,-2,5]",
        "output": "9",
        "explanation": "The entire array has the largest sum of 9."
      }
    ],
    "hint": "Original: Kadane's Algorithm"
  },
  {
    "id": 10,
    "title": "Color Sorter",
    "topic": "Array, Two Pointers, Sorting",
    "difficulty": "Medium",
    "description": "You're working in a factory that produces colored balls (red=0, white=1, blue=2). The balls come off the production line in random order, but they need to be sorted so that all red balls come first, followed by white balls, and then blue balls. Due to space constraints, you must sort the balls in-place without using extra space. This is a variation of the famous Dutch National Flag problem.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is 0, 1, or 2"
    ],
    "examples": [
      {
        "input": "nums = [2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": "Sorted order: red, red, white, white, blue, blue."
      },
      {
        "input": "nums = [1,0,2]",
        "output": "[0,1,2]",
        "explanation": "Sorted order: red, white, blue."
      }
    ],
    "hint": "Original: Sort an array of 0's, 1's and 2's"
  },
  {
    "id": 11,
    "title": "Stock Market Profit Finder",
    "topic": "Array, Dynamic Programming",
    "difficulty": "Easy",
    "description": "As a stock market analyst, you're given historical prices of a stock where prices[i] is the price on the i-th day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = [10,20,30]",
        "output": "20",
        "explanation": "Buy on day 1 (price = 10) and sell on day 3 (price = 30), profit = 20."
      }
    ],
    "hint": "Original: Stock Buy and Sell"
  },
  {
    "id": 12,
    "title": "Grid Rotator",
    "topic": "Array, Math, Matrix",
    "difficulty": "Medium",
    "description": "You are developing image processing software that needs to rotate images by 90 degrees clockwise. The image is represented by an n × n 2D matrix where each element represents a pixel. Your task is to rotate the image in-place, which means you have to modify the input 2D matrix directly without allocating another 2D matrix.",
    "constraints": [
      "n == matrix.length == matrix[i].length",
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "The matrix rotated 90 degrees clockwise."
      },
      {
        "input": "matrix = [[1,2],[3,4]]",
        "output": "[[3,1],[4,2]]",
        "explanation": "The matrix rotated 90 degrees clockwise."
      }
    ],
    "hint": "Original: Rotate Matrix"
  },
  {
    "id": 13,
    "title": "Interval Merger",
    "topic": "Array, Sorting",
    "difficulty": "Medium",
    "description": "As a scheduling coordinator for a large conference center, you're given an array of intervals where intervals[i] = [start_i, end_i] represents meeting times. Your task is to merge all overlapping intervals and return an array of the non-overlapping intervals that cover all meetings in the input. This will help optimize room utilization and prevent scheduling conflicts.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= start_i <= end_i <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Intervals [1,3] and [2,6] overlap, so they are merged into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] are considered overlapping and are merged."
      }
    ],
    "hint": "Original: Merge Overlapping Subintervals"
  },
  {
    "id": 14,
    "title": "Sorted List Merger",
    "topic": "Array, Two Pointers, Sorting",
    "difficulty": "Medium",
    "description": "You're working with memory-constrained embedded systems that need to merge two sorted arrays. Given two sorted integer arrays nums1 and nums2, and integers m and n representing the number of elements in nums1 and nums2 respectively, merge nums2 into nums1 as one sorted array without using extra space. nums1 has a length of m + n, where the first m elements are the actual elements and the last n elements are set to 0 and should be ignored.",
    "constraints": [
      "nums1.length == m + n",
      "nums2.length == n",
      "0 <= m, n <= 10^5",
      "1 <= m + n <= 10^5",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1,3,5,0,0,0], m = 3, nums2 = [2,4,6], n = 3",
        "output": "[1,2,3,4,5,6]",
        "explanation": "The arrays are merged into nums1 as a sorted array."
      },
      {
        "input": "nums1 = [1,2,0,0], m = 2, nums2 = [3,4], n = 2",
        "output": "[1,2,3,4]",
        "explanation": "The arrays are merged into nums1."
      }
    ],
    "hint": "Original: Merge two sorted arrays without extra space"
  },
  {
    "id": 15,
    "title": "Duplicate Number Finder",
    "topic": "Array, Two Pointers, Binary Search",
    "difficulty": "Medium",
    "description": "You're a detective investigating a case where an array of n + 1 integers contains numbers in the range [1, n] inclusive. There is exactly one repeated number, but you don't know how many times it appears. Your challenge is to find this duplicate number without modifying the array and using only constant extra space O(1), as the evidence must remain untouched for the court case.",
    "constraints": [
      "1 <= n <= 10^5",
      "nums.length == n + 1",
      "1 <= nums[i] <= n"
    ],
    "examples": [
      {
        "input": "nums = [1,3,4,2,2]",
        "output": "2",
        "explanation": "2 is the duplicate number in the array."
      },
      {
        "input": "nums = [3,1,3,4,2]",
        "output": "3",
        "explanation": "3 is the duplicate number in the array."
      }
    ],
    "hint": "Original: Find the duplicate in an array of N+1 integers"
  },
  {
    "id": 16,
    "title": "Missing and Repeated Number Finder",
    "topic": "Array, Hash Table, Math",
    "difficulty": "Medium",
    "description": "As a quality control inspector at a number factory, you've discovered that in an array of size n containing integers from 1 to n, one number is missing and another number is duplicated. Your task is to find both the missing number and the duplicated number efficiently to correct the production error and maintain quality standards.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "1 <= nums[i] <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [3,1,2,5,3]",
        "output": "[3,4]",
        "explanation": "3 is repeated and 4 is missing."
      },
      {
        "input": "nums = [1,2,2,4]",
        "output": "[2,3]",
        "explanation": "2 is repeated and 3 is missing."
      }
    ],
    "hint": "Original: Repeat and Missing Number"
  },
  {
    "id": 17,
    "title": "Out-of-Order Pair Counter",
    "topic": "Array, Binary Search, Divide and Conquer, Sorting",
    "difficulty": "Medium",
    "description": "As a data quality analyst, you need to measure how unsorted an array is by counting inversion pairs. Given an array of integers, count the number of inversions where an inversion is defined as a pair of indices (i, j) such that i < j and nums[i] > nums[j]. This measurement helps quantify how much work would be needed to sort the array completely.",
    "constraints": [
      "1 <= nums.length <= 5 * 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2,4,1,3,5]",
        "output": "3",
        "explanation": "The inversion pairs are (2,1), (4,1), and (4,3)."
      },
      {
        "input": "nums = [5,4,3,2,1]",
        "output": "10",
        "explanation": "Every pair is an inversion: total pairs = n(n-1)/2 = 10."
      }
    ],
    "hint": "Original: Inversion of Array"
  },
  {
    "id": 18,
    "title": "Grid Number Searcher",
    "topic": "Array, Binary Search, Matrix",
    "difficulty": "Medium",
    "description": "You're developing a search algorithm for a special sorted matrix where each row is sorted in non-decreasing order, and the first integer of each row is greater than the last integer of the previous row. Given a target integer, return true if target is in the matrix or false otherwise. Your solution must run in O(log(m * n)) time complexity to efficiently handle large datasets.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^9 <= matrix[i][j], target <= 10^9"
    ],
    "examples": [
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
        "output": "true",
        "explanation": "3 exists in the matrix."
      },
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
        "output": "false",
        "explanation": "13 does not exist in the matrix."
      }
    ],
    "hint": "Original: Search in a 2D matrix"
  },
  {
    "id": 19,
    "title": "Power Calculator",
    "topic": "Math, Recursion",
    "difficulty": "Medium",
    "description": "You're building a scientific calculator that needs to efficiently compute x raised to the power n (x^n). Implement a fast power function that handles both positive and negative exponents efficiently using logarithmic time complexity. This is crucial for your calculator to perform well with very large exponents.",
    "constraints": [
      "-100.0 < x < 100.0",
      "-2^31 <= n <= 2^31-1",
      "n is an integer",
      "Either x is not zero or n > 0",
      "-10^4 <= x^n <= 10^4"
    ],
    "examples": [
      {
        "input": "x = 2.00000, n = 10",
        "output": "1024.00000",
        "explanation": "2^10 = 1024."
      },
      {
        "input": "x = 3.00000, n = 3",
        "output": "27.00000",
        "explanation": "3^3 = 27."
      },
      {
        "input": "x = 2.00000, n = -2",
        "output": "0.25000",
        "explanation": "2^-2 = 1/4 = 0.25."
      }
    ],
    "hint": "Original: Pow(x, n)"
  },
  {
    "id": 20,
    "title": "Majority Element Finder",
    "topic": "Array, Hash Table, Divide and Conquer",
    "difficulty": "Easy",
    "description": "As an election analyst, you need to determine if any candidate has received the majority of votes (more than n/2 votes). Given an array nums of size n, return the majority element that appears more than ⌊n/2⌋ times. You may assume that the majority element always exists in the array, making your analysis straightforward.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 5 * 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3,2,3]",
        "output": "3",
        "explanation": "3 appears 2 out of 3 times, which is more than n/2."
      },
      {
        "input": "nums = [1,1,2]",
        "output": "1",
        "explanation": "1 appears 2 out of 3 times, which is more than n/2."
      }
    ],
    "hint": "Original: Majority Element (>n/2 times)"
  },
  {
    "id": 21,
    "title": "Frequent Element Finder",
    "topic": "Array, Hash Table",
    "difficulty": "Medium",
    "description": "In a political analysis scenario, you need to identify all elements that appear more than ⌊n/3⌋ times in an array. These represent significant minority positions that could form coalitions. Given an integer array of size n, find all elements that appear more than ⌊n/3⌋ times, as these could be potential coalition builders in a multi-party system.",
    "constraints": [
      "1 <= nums.length <= 5 * 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3,2,3]",
        "output": "[3]",
        "explanation": "3 appears 2 out of 3 times, which is more than ⌊3/3⌋ = 1."
      },
      {
        "input": "nums = [1,2,3,1,2]",
        "output": "[1,2]",
        "explanation": "1 and 2 each appear 2 out of 5 times, which is more than ⌊5/3⌋ ≈ 1.67."
      }
    ],
    "hint": "Original: Majority Element (n/3 times)"
  },
  {
    "id": 22,
    "title": "Robot Path Counter",
    "topic": "Math, Dynamic Programming, Combinatorics",
    "difficulty": "Medium",
    "description": "You're programming a robot that starts in the top-left corner of an m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there? This problem helps in pathfinding algorithms for autonomous robots in constrained environments.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 possible unique paths from top-left to bottom-right."
      },
      {
        "input": "m = 2, n = 2",
        "output": "2",
        "explanation": "Two possible paths: right-down or down-right."
      }
    ],
    "hint": "Original: Grid Unique Paths"
  },
  {
    "id": 23,
    "title": "Double Reverse Pair Counter",
    "topic": "Array, Binary Search, Divide and Conquer",
    "difficulty": "Hard",
    "description": "In a financial analysis system, you need to identify significant price discrepancies. Given an array nums, return the number of reverse pairs where a reverse pair is a pair (i, j) where i < j and nums[i] > 2 * nums[j]. This helps identify extreme market anomalies that could indicate trading opportunities or market manipulation.",
    "constraints": [
      "1 <= nums.length <= 5 * 10^4",
      "-2^31 <= nums[i] <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "nums = [1,3,2,3,1]",
        "output": "2",
        "explanation": "The reverse pairs are (3,1) and (3,1) where 3 > 2*1."
      },
      {
        "input": "nums = [5,2,3]",
        "output": "1",
        "explanation": "The reverse pair is (5,2) where 5 > 2*2."
      }
    ],
    "hint": "Original: Reverse Pairs"
  },
  {
    "id": 24,
    "title": "Number Pair Sum Hunter",
    "topic": "Array, Hash Table",
    "difficulty": "Easy",
    "description": "In a treasure hunting game, you're given a list of numbers and a target sum. Your quest is to find two different numbers in the list that add up to the target sum. Return the indices of these two numbers. You may assume that each input would have exactly one solution, and you may not use the same element twice, as each treasure can only be used once in the combination.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists"
    ],
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "hint": "Original: 2Sum Problem"
  },
  {
    "id": 25,
    "title": "Four Number Sum Finder",
    "topic": "Array, Two Pointers, Sorting",
    "difficulty": "Medium",
    "description": "As a cryptanalyst, you're trying to break a four-number combination lock. Given an array nums of n integers and a target value, find all unique quadruplets in the array which gives the sum of target. Each quadruplet must contain distinct elements from the array, and the solution set must not contain duplicate quadruplets.",
    "constraints": [
      "1 <= nums.length <= 200",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1,0,-1,0,-2,2], target = 0",
        "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
        "explanation": "These are the unique quadruplets that sum to 0."
      },
      {
        "input": "nums = [1,2,3,4], target = 10",
        "output": "[[1,2,3,4]]",
        "explanation": "The only quadruplet that sums to 10."
      }
    ],
    "hint": "Original: 4-Sum Problem"
  },
  {
    "id": 26,
    "title": "Longest Number Chain Finder",
    "topic": "Array, Hash Table, Union Find",
    "difficulty": "Medium",
    "description": "As a genealogist studying numerical family trees, you want to find the longest sequence of consecutive numbers in an unsorted array of integers. For example, in the array [100, 4, 200, 1, 3, 2], the longest consecutive elements sequence is [1, 2, 3, 4]. Return the length of this sequence. Your algorithm should run in O(n) time complexity to handle large family trees efficiently.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100,4,200,1,3,2]",
        "output": "4",
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4] with length 4."
      },
      {
        "input": "nums = [5,1,3]",
        "output": "1",
        "explanation": "There are no consecutive sequences longer than 1."
      }
    ],
    "hint": "Original: Longest Consecutive Sequence"
  },
  {
    "id": 27,
    "title": "Subarray Sum Finder",
    "topic": "Array, Hash Table",
    "difficulty": "Medium",
    "description": "As a data analyst, you're looking for the longest contiguous subarray that sums to exactly k. Given an integer array nums and an integer k, return the maximum length of a contiguous subarray that sums to k. If there is no such subarray, return 0. This helps identify significant patterns in time-series data.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1,-1,5,-2,3], k = 3",
        "output": "4",
        "explanation": "The subarray [1,-1,5,-2] sums to 3 and has length 4."
      },
      {
        "input": "nums = [1,2,3], k = 6",
        "output": "3",
        "explanation": "The entire array sums to 6."
      }
    ],
    "hint": "Original: Largest Subarray with K sum"
  },
  {
    "id": 28,
    "title": "XOR Subarray Counter",
    "topic": "Array, Hash Table, Bit Manipulation",
    "difficulty": "Medium",
    "description": "In a cryptographic analysis task, you need to count the number of contiguous subarrays where the XOR of all elements equals k. Given an array of integers nums and an integer k, return the number of contiguous subarrays where the XOR of all the elements in the subarray is k. This helps identify patterns in encrypted data streams.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^6",
      "0 <= k <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [4,2,2,6,4], k = 6",
        "output": "4",
        "explanation": "The subarrays with XOR 6 are [4,2], [4,2,2,6], [2,2,6], [6]."
      },
      {
        "input": "nums = [1,2,3], k = 3",
        "output": "2",
        "explanation": "The subarrays with XOR 3 are [3] and [1,2]."
      }
    ],
    "hint": "Original: Count number of subarrays with given xor K"
  },
  {
    "id": 29,
    "title": "Ancient Text Pattern Analyzer",
    "topic": "Hash Table, String, Sliding Window",
    "difficulty": "Medium",
    "description": "As a linguist studying ancient texts, you want to find the longest substring without repeating characters. Given a string s, find the length of the longest substring without repeating characters. This helps identify unique patterns in ancient languages that could reveal hidden meanings or grammatical structures.",
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "hint": "Use a sliding window approach with a hash set to track characters"
  },
  {
    "id": 30,
    "title": "Network Packet Reversal System",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "As a network engineer, you're designing a packet reassembly system where data packets arrive in reverse order. Reverse a singly linked list to reconstruct the original data stream. Given the head of a linked list, reverse it and return the new head.",
    "constraints": [
      "Number of nodes in the list is in the range [0, 5000]",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "explanation": "The reversed list shows packets in correct order"
      }
    ],
    "hint": "Use three pointers: previous, current, and next"
  },
  {
    "id": 31,
    "title": "Data Stream Middle Monitor",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "As a data analyst monitoring real-time streams, you need to find the middle element of a linked list. If there are two middle nodes, return the second one. This helps in balancing data processing loads.",
    "constraints": [
      "1 <= Number of nodes <= 100",
      "1 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[3,4,5]",
        "explanation": "Middle node is 3"
      }
    ],
    "hint": "Use slow and fast pointer technique"
  },
  {
    "id": 32,
    "title": "Sorted Data Merger",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "As a database administrator, you need to merge two sorted linked lists from different tables. Return a new sorted list by splicing together the nodes of the first two lists, preserving order.",
    "constraints": [
      "Number of nodes in both lists is in range [0, 50]",
      "-100 <= Node.val <= 100",
      "Both lists are sorted in non-decreasing order"
    ],
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "Merged while maintaining sorted order"
      }
    ],
    "hint": "Use dummy node to handle edge cases"
  },
  {
    "id": 33,
    "title": "Network Node Remover",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a security engineer, you need to remove the nth node from the end of a network node chain. This helps isolate compromised nodes while maintaining chain integrity.",
    "constraints": [
      "1 <= Number of nodes <= 30",
      "1 <= n <= Number of nodes"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], n = 2",
        "output": "[1,2,3,5]",
        "explanation": "Second node from end (value 4) is removed"
      }
    ],
    "hint": "Use two pointers with n node gap"
  },
  {
    "id": 34,
    "title": "Encrypted Number Adder",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a cryptographer, you're working with numbers stored as reversed linked lists. Add two numbers where each digit is stored in a node (reverse order) and return the sum as a linked list.",
    "constraints": [
      "Number of nodes in each list is in range [1, 100]",
      "0 <= Node.val <= 9",
      "Numbers don't contain leading zeros"
    ],
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807"
      }
    ],
    "hint": "Handle carry-over and different list lengths"
  },
  {
    "id": 35,
    "title": "Secure Node Deletion",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a system architect, you need to delete a node from a linked list given only access to that node. Implement an O(1) solution that preserves data integrity without accessing previous nodes.",
    "constraints": [
      "Number of nodes in list >= 2",
      "Node.val is unique",
      "Given node is not the tail node"
    ],
    "examples": [
      {
        "input": "node = 3 from [1,2,3,4]",
        "output": "[1,2,4]",
        "explanation": "Node 3 is replaced with node 4's value"
      }
    ],
    "hint": "Copy next node's value and skip next node"
  },
  {
    "id": 36,
    "title": "Network Intersection Locator",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "As a network investigator, find where two linked lists intersect in a Y-shaped configuration. This helps identify shared infrastructure nodes between two networks.",
    "constraints": [
      "Number of nodes in lists are in range [1, 1000]",
      "Node values are unique",
      "No cycles in either list"
    ],
    "examples": [
      {
        "input": "listA = [1,2,3,4], listB = [7,8,3,4]",
        "output": "Node with value 3",
        "explanation": "Lists intersect at node with value 3"
      }
    ],
    "hint": "Traverse both lists to find common node"
  },
  {
    "id": 37,
    "title": "Data Cycle Detector",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a data quality engineer, detect if a linked list has a cycle where some node points to a previous node. This helps identify infinite loops in data processing pipelines.",
    "constraints": [
      "Number of nodes in range [0, 1000]",
      "Node values are unique"
    ],
    "examples": [
      {
        "input": "head = [3,2,0,-4] with pos=1",
        "output": "true",
        "explanation": "Tail connects to second node"
      }
    ],
    "hint": "Use Floyd's cycle detection algorithm"
  },
  {
    "id": 38,
    "title": "Batch Data Reverser",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a data processor, reverse nodes in k-group batches in a linked list. If nodes aren't divisible by k, leave them as-is. This helps in batch processing optimization.",
    "constraints": [
      "Number of nodes in range [0, 1000]",
      "1 <= k <= number of nodes"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 3",
        "output": "[3,2,1,4,5]",
        "explanation": "First 3 nodes reversed, rest unchanged"
      }
    ],
    "hint": "Use recursion or iterative group reversal"
  },
  {
    "id": 39,
    "title": "Data Palindrome Validator",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "As a data integrity specialist, check if a linked list is a palindrome when read forward and backward. This verifies data symmetry in storage systems.",
    "constraints": [
      "Number of nodes in range [1, 1000]",
      "0 <= Node.val <= 9"
    ],
    "examples": [
      {
        "input": "head = [1,2,2,1]",
        "output": "true",
        "explanation": "List reads same forwards and backwards"
      }
    ],
    "hint": "Find middle, reverse second half, and compare"
  },
  {
    "id": 40,
    "title": "Cycle Origin Finder",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a system diagnostician, find the starting node of a cycle in a linked list. This helps pinpoint the exact location of infinite loops in processing systems.",
    "constraints": [
      "Number of nodes in range [1, 1000]",
      "Node values are unique"
    ],
    "examples": [
      {
        "input": "head = [3,2,0,-4] with pos=1",
        "output": "Node with value 2",
        "explanation": "Cycle starts at second node"
      }
    ],
    "hint": "Use Floyd's algorithm after cycle detection"
  },
  {
    "id": 41,
    "title": "Multi-level Data Flattener",
    "topic": "Linked List",
    "difficulty": "Hard",
    "description": "As a data architect, flatten a multilevel doubly linked list where nodes may have child pointers. Convert the hierarchy into a single-level list while maintaining order.",
    "constraints": [
      "Number of nodes <= 1000",
      "1 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5,6] with children at 3 and 5",
        "output": "[1,2,3,7,8,9,4,5,6]",
        "explanation": "Children are inserted after their parent nodes"
      }
    ],
    "hint": "Use depth-first search with stack"
  },
  {
    "id": 42,
    "title": "Data Rotator",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a data storage optimizer, rotate a linked list to the right by k places. This helps in balancing data distribution across storage nodes.",
    "constraints": [
      "Number of nodes in range [0, 500]",
      "0 <= k <= 1000"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[4,5,1,2,3]",
        "explanation": "List rotated right by 2 places"
      }
    ],
    "hint": "Connect tail to head and find new tail"
  },
  {
    "id": 43,
    "title": "Secure List Cloner",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a security specialist, create a deep copy of a linked list with random pointers. This helps create secure backups while maintaining all node relationships.",
    "constraints": [
      "Number of nodes in range [0, 1000]",
      "Node values are unique"
    ],
    "examples": [
      {
        "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "Deep copy with same structure",
        "explanation": "New list with identical relationships"
      }
    ],
    "hint": "Use hash map to store old node -> new node mapping"
  },
  {
    "id": 44,
    "title": "Ancient Number Triangulator",
    "topic": "Array, Two Pointers",
    "difficulty": "Medium",
    "description": "As an archaeologist, find all unique triplets in ancient number tablets that sum to zero. This helps decode numerical patterns in ancient accounting systems.",
    "constraints": [
      "3 <= nums.length <= 1000",
      "-1000 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]",
        "explanation": "Unique triplets that sum to zero"
      }
    ],
    "hint": "Sort array and use two pointers"
  },
  {
    "id": 45,
    "title": "Rainwater Harvesting Calculator",
    "topic": "Array, Two Pointers",
    "difficulty": "Hard",
    "description": "As a water resource engineer, calculate how much rainwater can be trapped between ancient temple structures given their heights. This helps in historical water management analysis.",
    "constraints": [
      "n == height.length",
      "1 <= n <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "6 units of rainwater can be trapped"
      }
    ],
    "hint": "Use two pointers or precompute left/right max arrays"
  },
  {
    "id": 46,
    "title": "Temple Scroll Duplicate Remover",
    "topic": "Array",
    "difficulty": "Easy",
    "description": "As a scribe, remove duplicates from sorted temple scrolls in-place while maintaining order. Return the number of unique entries.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order"
    ],
    "examples": [
      {
        "input": "nums = [1,1,2,2,3,4,4,5]",
        "output": "5",
        "explanation": "5 unique numbers: [1,2,3,4,5]"
      }
    ],
    "hint": "Use two pointers - reader and writer"
  },
  {
    "id": 47,
    "title": "Signal Fire Counter",
    "topic": "Array",
    "difficulty": "Easy",
    "description": "As a watchtower guard, count the maximum consecutive signal fires (1s) in a binary array. This helps determine communication range between ancient outposts.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "nums[i] is either 0 or 1"
    ],
    "examples": [
      {
        "input": "nums = [1,1,0,1,1,1,0,1,1]",
        "output": "3",
        "explanation": "Maximum consecutive 1s is 3"
      }
    ],
    "hint": "Maintain running count and max count"
  },
  {
    "id": 48,
    "title": "Ritual Scheduling Optimizer",
    "topic": "Greedy",
    "difficulty": "Easy",
    "description": "As a temple coordinator, schedule the maximum number of rituals in one room without overlapping. Each ritual has start and end times. This maximizes spiritual efficiency.",
    "constraints": [
      "1 <= N <= 10^5",
      "1 <= start[i] < end[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "N=6, start[]=[1,3,0,5,8,5], end[]=[2,4,6,7,9,9]",
        "output": "4",
        "explanation": "Maximum 4 non-overlapping rituals can be scheduled"
      }
    ],
    "hint": "Sort by end times and select non-conflicting rituals"
  },
  {
    "id": 49,
    "title": "Chariot Platform Allocator",
    "topic": "Greedy",
    "difficulty": "Medium",
    "description": "As a chariot master, find the minimum number of platforms required for a railway station so no chariot waits. Given arrival and departure times, calculate platform needs.",
    "constraints": [
      "1 <= n <= 50000",
      "0 <= arr[i] <= dep[i] <= 2359"
    ],
    "examples": [
      {
        "input": "arr[]=[900,940,950,1100,1500,1800], dep[]=[910,1200,1120,1130,1900,2000]",
        "output": "3",
        "explanation": "Minimum 3 platforms needed"
      }
    ],
    "hint": "Sort both arrays and use two pointers"
  },
  {
    "id": 50,
    "title": "Artifact Profit Maximizer",
    "topic": "Greedy",
    "difficulty": "Medium",
    "description": "As a museum curator, schedule artifact jobs with deadlines and profits to maximize total profit. Each job takes one unit of time and has a deadline.",
    "constraints": [
      "1 <= N <= 1000",
      "1 <= Deadline <= 100",
      "1 <= Profit <= 500"
    ],
    "examples": [
      {
        "input": "Jobs = [(1,4,20),(2,1,10),(3,1,40),(4,1,30)]",
        "output": "60",
        "explanation": "Jobs 1 and 3 give maximum profit"
      }
    ],
    "hint": "Sort by profit and assign to latest available slot"
  },
  {
    "id": 51,
    "title": "Expedition Pack Optimizer",
    "topic": "Greedy",
    "difficulty": "Medium",
    "description": "As an expedition planner, maximize value of items in a knapsack with fractional allowed items. This helps optimize supplies for long journeys.",
    "constraints": [
      "1 <= N <= 1000",
      "1 <= W <= 1000",
      "1 <= value[i], weight[i] <= 1000"
    ],
    "examples": [
      {
        "input": "W=50, value[]=[60,100,120], weight[]=[10,20,30]",
        "output": "240.0",
        "explanation": "Take full items of 10 and 20, fraction of 30"
      }
    ],
    "hint": "Sort by value/weight ratio in descending order"
  },
  {
    "id": 52,
    "title": "Ancient Coin Counter",
    "topic": "Greedy",
    "difficulty": "Easy",
    "description": "As a merchant, find the minimum number of ancient coins needed to make exact change. This optimizes currency transactions in historical markets.",
    "constraints": [
      "1 <= amount <= 10^4",
      "1 <= coins.length <= 12",
      "0 <= coins[i] <= 1000"
    ],
    "examples": [
      {
        "input": "coins = [1,2,5], amount = 11",
        "output": "3",
        "explanation": "11 = 5 + 5 + 1"
      }
    ],
    "hint": "Use greedy with largest denominations first"
  },
  {
    "id": 53,
    "title": "Cookie Distributor",
    "topic": "Greedy",
    "difficulty": "Easy",
    "description": "As a temple cook, assign cookies to children with greed factors. Each child gets one cookie that satisfies their greed. Maximize number of content children.",
    "constraints": [
      "1 <= children, cookies <= 10^4",
      "0 <= greed[i], size[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "greed = [1,2,3], cookies = [1,1]",
        "output": "1",
        "explanation": "Only one child can be satisfied"
      }
    ],
    "hint": "Sort both arrays and use two pointers"
  },
  {
    "id": 54,
    "title": "Ancient Treasure Sum Finder",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "description": "As an archaeologist exploring a pharaoh's tomb, you discover ancient tablets with numbers inscribed on them. Find all possible sums that can be formed by selecting subsets of these numbers. This could reveal hidden combinations to unlock secret chambers.",
    "constraints": [
      "1 <= N <= 15",
      "0 <= arr[i] <= 1000"
    ],
    "examples": [
      {
        "input": "arr = [2, 3]",
        "output": "[0, 2, 3, 5]",
        "explanation": "Subset sums: []→0, [2]→2, [3]→3, [2,3]→5"
      }
    ],
    "hint": "Use recursion to generate all subsets"
  },
  {
    "id": 55,
    "title": "Duplicate Artifact Subset Finder",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "description": "While cataloging a museum's collection, you encounter duplicate artifacts with identical markings. Find all unique subsets of these artifacts, handling duplicates appropriately to create an accurate inventory.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1,2,2]",
        "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
        "explanation": "All unique subsets including handling duplicates"
      }
    ],
    "hint": "Sort first and skip duplicates during recursion"
  },
  {
    "id": 56,
    "title": "Ritual Offering Combiner",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "description": "As a high priest preparing for a ceremony, you need to combine offerings that sum to a specific sacred number. Each offering can be used multiple times. Find all unique combinations that achieve the target sum.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "2 <= target <= 500",
      "1 <= candidates[i] <= 200"
    ],
    "examples": [
      {
        "input": "candidates = [2,3,6,7], target = 7",
        "output": "[[2,2,3],[7]]",
        "explanation": "2+2+3=7 and 7=7"
      }
    ],
    "hint": "Use backtracking with index and remaining target"
  },
  {
    "id": 57,
    "title": "Unique Offering Combiner",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "description": "Prepare for an exclusive ceremony where each offering can be used only once. Find all unique combinations that sum to the sacred target number, handling duplicate offerings appropriately.",
    "constraints": [
      "1 <= candidates.length <= 100",
      "1 <= target <= 30",
      "1 <= candidates[i] <= 50"
    ],
    "examples": [
      {
        "input": "candidates = [10,1,2,7,6,1,5], target = 8",
        "output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
        "explanation": "All unique combinations summing to 8"
      }
    ],
    "hint": "Sort and skip duplicates when same as previous"
  },
  {
    "id": 58,
    "title": "Sacred Text Partitionor",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "description": "As a scribe transcribing sacred texts, partition ancient scriptures such that every segment is a palindrome. This preserves the spiritual harmony of the text in accordance with temple traditions.",
    "constraints": [
      "1 <= s.length <= 16",
      "s contains only lowercase English letters"
    ],
    "examples": [
      {
        "input": "s = \"aab\"",
        "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
        "explanation": "All possible palindrome partitions"
      }
    ],
    "hint": "Use backtracking with palindrome checking"
  },
  {
    "id": 59,
    "title": "Ceremonial Sequence Finder",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "description": "As the master of ceremonies, determine the k-th permutation sequence of sacred symbols for an important ritual. The order of symbols must follow ancient traditions.",
    "constraints": [
      "1 <= n <= 9",
      "1 <= k <= n!"
    ],
    "examples": [
      {
        "input": "n = 3, k = 3",
        "output": "\"213\"",
        "explanation": "Permutations in order: 123, 132, 213, 231, 312, 321"
      }
    ],
    "hint": "Use factorial number system to determine positions"
  },
  {
    "id": 60,
    "title": "Sac Symbol Arrangement Generator",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "description": "Generate all possible arrangements of sacred symbols for meditation rituals. Each arrangement represents a different spiritual path for enlightenment.",
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "All permutations of the array"
      }
    ],
    "hint": "Use backtracking with swapping technique"
  },
  {
    "id": 61,
    "title": "Royal Court Arranger",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "description": "As the royal architect, arrange N queens on a N×N chessboard such that no two queens threaten each other. This represents the optimal court arrangement for maximum diplomatic efficiency.",
    "constraints": [
      "1 <= n <= 9"
    ],
    "examples": [
      {
        "input": "n = 4",
        "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
        "explanation": "Two distinct solutions for 4 queens"
      }
    ],
    "hint": "Use backtracking with column, diagonal and anti-diagonal checks"
  },
  {
    "id": 62,
    "title": "Ancient Number Grid Solver",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "description": "Solve a sacred number grid puzzle found in an ancient temple. Fill the 9×9 grid with digits 1-9 such that each row, column, and 3×3 subgrid contains all digits without repetition.",
    "constraints": [
      "board.length == 9",
      "board[i].length == 9",
      "board[i][j] is a digit or '.'",
      "Input is guaranteed to be solvable"
    ],
    "examples": [
      {
        "input": "Partially filled sudoku board",
        "output": "Completely filled valid sudoku",
        "explanation": "All rows, columns and 3×3 boxes contain 1-9 exactly once"
      }
    ],
    "hint": "Use backtracking with efficient candidate checking"
  },
  {
    "id": 63,
    "title": "Kingdom Region Colorer",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "description": "As a cartographer mapping the kingdom's regions, color adjacent regions with different colors using at most M colors. This creates visually distinct territories for royal administration.",
    "constraints": [
      "N <= 20",
      "M <= 10"
    ],
    "examples": [
      {
        "input": "Graph with 4 nodes, M = 3",
        "output": "true",
        "explanation": "The graph can be colored with 3 colors"
      }
    ],
    "hint": "Try colors for each node and check validity with neighbors"
  },
  {
    "id": 64,
    "title": "Temple Maze Navigator",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "description": "Navigate through an ancient temple maze to find the path to the sacred chamber. The maze contains obstacles (1s) and open paths (0s), starting from (0,0) to (N-1,N-1).",
    "constraints": [
      "n == maze.length == maze[i].length",
      "2 <= n <= 5",
      "maze[i][j] is 0 or 1"
    ],
    "examples": [
      {
        "input": "maze = [[1,0,0,0],[1,1,0,1],[1,1,0,0],[0,1,1,1]]",
        "output": "[\"DDRDRR\",\"DRDDRR\"]",
        "explanation": "Two paths from start to end: Down,Down,Right,Down,Right,Right and Down,Right,Down,Down,Right,Right"
      }
    ],
    "hint": "Use DFS with backtracking, moving in all 4 directions"
  },
  {
    "id": 65,
    "title": "Ancient Dictionary Word Breaker",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "description": "Break a sacred inscription into valid words from an ancient dictionary. Find all possible ways to segment the text into space-separated sequences of dictionary words.",
    "constraints": [
      "1 <= s.length <= 15",
      "1 <= wordDict.length <= 100",
      "1 <= wordDict[i].length <= 10"
    ],
    "examples": [
      {
        "input": "s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]",
        "output": "[\"cats and dog\",\"cat sand dog\"]",
        "explanation": "Two ways to break the sentence"
      }
    ],
    "hint": "Use backtracking with memoization"
  },
  {
    "id": 66,
    "title": "Sacred Root Calculator",
    "topic": "Binary Search",
    "difficulty": "Medium",
    "description": "Calculate the N-th root of a sacred number using ancient mathematical techniques. Find the precise value to unlock hidden chambers in the pyramid.",
    "constraints": [
      "1 <= N <= 10",
      "1 <= M <= 10^9",
      "Error tolerance: 1e-6"
    ],
    "examples": [
      {
        "input": "N = 3, M = 27",
        "output": "3.000000",
        "explanation": "Cube root of 27 is 3"
      }
    ],
    "hint": "Use binary search on possible root values"
  },
  {
    "id": 67,
    "title": "Tablet Value Median Finder",
    "topic": "Binary Search",
    "difficulty": "Hard",
    "description": "Find the median value of numbers inscribed on ancient stone tablets arranged in a matrix. Each row is sorted, helping priests identify the central sacred value.",
    "constraints": [
      "1 <= R, C <= 150",
      "1 <= matrix[i][j] <= 2000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,3,5],[2,6,9],[3,6,9]]",
        "output": "5",
        "explanation": "Sorted elements: [1,2,3,3,5,6,6,9,9], median = 5"
      }
    ],
    "hint": "Use binary search on the median value"
  },
  {
    "id": 68,
    "title": "Lone Artifact Finder",
    "topic": "Binary Search",
    "difficulty": "Medium",
    "description": "In a sorted collection of ancient artifacts where all appear twice except one, find the unique artifact using binary search techniques favored by temple scholars.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1,1,2,3,3,4,4,8,8]",
        "output": "2",
        "explanation": "2 appears only once, all others appear twice"
      }
    ],
    "hint": "Use binary search on even indices"
  },
  {
    "id": 69,
    "title": "Rotated Scroll Searcher",
    "topic": "Binary Search",
    "difficulty": "Medium",
    "description": "Search for a sacred symbol in a rotated scroll where the symbols were rearranged during an ancient ceremony. Find the pivot point and then the target symbol.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "All values are unique"
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "Target 0 found at index 4"
      }
    ],
    "hint": "Find pivot first, then search in the appropriate half"
  },
  {
    "id": 70,
    "title": "Dual Scroll Median Finder",
    "topic": "Binary Search",
    "difficulty": "Hard",
    "description": "Find the median of two sorted sacred scrolls containing important numerical records. This combined median represents the central value of ancient historical data.",
    "constraints": [
      "nums1.length == m",
      "nums2.length == n",
      "0 <= m, n <= 1000",
      "1 <= m + n <= 2000"
    ],
    "examples": [
      {
        "input": "nums1 = [1,3], nums2 = [2]",
        "output": "2.0",
        "explanation": "Merged array = [1,2,3], median = 2"
      }
    ],
    "hint": "Use binary search on the smaller array"
  },
  {
    "id": 71,
    "title": "Dual Scroll Element Finder",
    "topic": "Binary Search",
    "difficulty": "Hard",
    "description": "Find the k-th smallest element in two sorted sacred scrolls containing temple records. This helps priests locate specific historical entries efficiently.",
    "constraints": [
      "1 <= m, n <= 10^5",
      "1 <= k <= m + n"
    ],
    "examples": [
      {
        "input": "nums1 = [1,3,5], nums2 = [2,4,6], k = 4",
        "output": "4",
        "explanation": "Merged sorted: [1,2,3,4,5,6], 4th element is 4"
      }
    ],
    "hint": "Use binary search to partition both arrays"
  },
  {
    "id": 72,
    "title": "Scroll Page Allocator",
    "topic": "Binary Search",
    "difficulty": "Hard",
    "description": "Allocate ancient scroll pages to scribes for transcription, minimizing the maximum pages any scribe copies. This optimizes the sacred text reproduction process.",
    "constraints": [
      "1 <= N <= 10^5",
      "1 <= A[i] <= 10^6",
      "1 <= M <= N"
    ],
    "examples": [
      {
        "input": "pages = [12,34,67,90], scribes = 2",
        "output": "113",
        "explanation": "Scribe 1: [12,34,67] = 113, Scribe 2: [90] = 90, max = 113"
      }
    ],
    "hint": "Use binary search on possible maximum page limits"
  },
  {
    "id": 73,
    "title": "Stable Cow Arranger",
    "topic": "Binary Search",
    "difficulty": "Medium",
    "description": "Arrange aggressive cows in temple stables to maximize the minimum distance between them. This prevents conflicts during sacred ceremonies.",
    "constraints": [
      "2 <= N <= 10^5",
      "2 <= C <= N",
      "0 <= stalls[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "stalls = [1,2,4,8,9], cows = 3",
        "output": "3",
        "explanation": "Cows at positions 1, 4, 8 with min distance 3"
      }
    ],
    "hint": "Use binary search on possible minimum distances"
  },
  {
    "id": 74,
    "title": "Sacred Priority Queue",
    "topic": "Heap",
    "difficulty": "Medium",
    "description": "Implement a max heap structure to manage temple priorities according to ancient traditions. This data structure helps in ritual scheduling and resource allocation.",
    "constraints": [
      "1 <= capacity <= 10^3",
      "1 <= operations <= 10^3"
    ],
    "examples": [
      {
        "input": "Insert: [5,3,8,1], ExtractMax: []",
        "output": "[8,5,3,1]",
        "explanation": "Max heap structure maintains max element at root"
      }
    ],
    "hint": "Use array representation with index calculations"
  },
  {
    "id": 75,
    "title": "K-th Sacred Element Finder",
    "topic": "Heap",
    "difficulty": "Medium",
    "description": "Find the K-th largest element in a collection of sacred artifacts. This helps identify important items for ceremonial use according to their spiritual significance.",
    "constraints": [
      "1 <= k <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3,2,1,5,6,4], k = 2",
        "output": "5",
        "explanation": "2nd largest element is 5"
      }
    ],
    "hint": "Use min-heap of size k"
  },
  {
    "id": 76,
    "title": "Royal Sum Combiner",
    "topic": "Heap",
    "difficulty": "Medium",
    "description": "Find the maximum sum combinations from two arrays of royal offerings, selecting one from each array. This helps create optimal offering pairs for maximum spiritual benefit.",
    "constraints": [
      "1 <= N <= 10^3",
      "1 <= K <= min(10^3, N*N)",
      "1 <= A[i], B[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "A = [1,2,3], B = [4,5,6], K = 3",
        "output": "[9,8,8]",
        "explanation": "Max sums: 3+6=9, 3+5=8, 2+6=8"
      }
    ],
    "hint": "Use max-heap with visited set to avoid duplicates"
  },
  {
    "id": 77,
    "title": "Streaming Oracle",
    "topic": "Heap",
    "difficulty": "Hard",
    "description": "Design a data structure that continuously receives sacred numbers and can instantly find the median. This helps priests maintain balance in ongoing rituals.",
    "constraints": [
      "1 <= operations <= 10^4",
      "-10^5 <= num <= 10^5"
    ],
    "examples": [
      {
        "input": "Add: [1,2,3], FindMedian: []",
        "output": "2.0",
        "explanation": "After adding 1,2,3, median is 2"
      }
    ],
    "hint": "Use two heaps: max-heap for left half, min-heap for right half"
  },
  {
    "id": 78,
    "title": "Multi-Scroll Merger",
    "topic": "Heap",
    "difficulty": "Hard",
    "description": "Merge K sorted sacred scrolls into a single sorted scroll. This combines historical records from different temple archives into a unified chronology.",
    "constraints": [
      "0 <= K <= 10^3",
      "0 <= total elements <= 10^4"
    ],
    "examples": [
      {
        "input": "scrolls = [[1,3,5],[2,4,6],[0,7,8]]",
        "output": "[0,1,2,3,4,5,6,7,8]",
        "explanation": "All scrolls merged in sorted order"
      }
    ],
    "hint": "Use min-heap to store the front elements of each array"
  },
  {
    "id": 79,
    "title": "Frequency Oracle",
    "topic": "Heap",
    "difficulty": "Medium",
    "description": "Find the K most frequent sacred symbols in ancient texts. This helps priests identify the most spiritually significant symbols for ceremonial focus.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= k <= number of unique elements",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1,2]",
        "explanation": "1 appears 3 times, 2 appears 2 times (top 2 most frequent)"
      }
    ],
    "hint": "Use frequency map followed by min-heap of size k"
  },
  {
    "id": 80,
    "title": "Sacred Scroll Stack Builder",
    "topic": "Stack",
    "difficulty": "Easy",
    "description": "As a temple archivist, implement a stack data structure using arrays to store sacred scrolls. This Last-In-First-Out system helps preserve the order of ancient rituals where the most recent scroll must be accessed first.",
    "constraints": [
      "1 <= operations <= 100",
      "0 <= values <= 100"
    ],
    "examples": [
      {
        "input": "Push: [5,3,7], Pop: []",
        "output": "[7,3,5]",
        "explanation": "Scrolls are retrieved in reverse order of storage"
      }
    ],
    "hint": "Maintain a pointer to track the top element"
  },
  {
    "id": 81,
    "title": "Ritual Queue Implementer",
    "topic": "Queue",
    "difficulty": "Easy",
    "description": "Implement a queue using arrays to manage pilgrims waiting for sacred ceremonies. This First-In-First- system ensures fair access to temple rituals according to arrival time.",
    "constraints": [
      "1 <= operations <= 100",
      "0 <= values <= 100"
    ],
    "examples": [
      {
        "input": "Enqueue: [5,3,7], Dequeue: []",
        "output": "[5,3,7]",
        "explanation": "Pilgrims are served in the order they arrived"
      }
    ],
    "hint": "Use two pointers for front and rear of queue"
  },
  {
    "id": 82,
    "title": "Stack from Ritual Queue",
    "topic": "Stack, Queue",
    "difficulty": "Medium",
    "description": "Create a stack data structure using only a single queue to store sacred artifacts. This clever arrangement helps temple scribes maximize limited storage space while maintaining ritual access patterns.",
    "constraints": [
      "1 <= operations <= 100",
      "0 <= values <= 100"
    ],
    "examples": [
      {
        "input": "Push: [5,3,7], Pop: []",
        "output": "7",
        "explanation": "Last artifact added (7) is first to be removed"
      }
    ],
    "hint": "For each push, rotate the queue to maintain stack order"
  },
  {
    "id": 83,
    "title": "Queue from Sacred Stacks",
    "topic": "Queue, Stack",
    "difficulty": "Medium",
    "description": "Implement a queue using two stacks to manage temple offerings. This O(1) amortized method efficiently processes offerings while maintaining the sacred first-come-first-served principle.",
    "constraints": [
      "1 <= operations <= 100",
      "0 <= values <= 100"
    ],
    "examples": [
      {
        "input": "Enqueue: [5,3,7], Dequeue: []",
        "output": "5",
        "explanation": "First offering (5) is first to be processed"
      }
    ],
    "hint": "Use two stacks: one for input, one for output"
  },
  {
    "id": 84,
    "title": "Sacred Symbol Balance Checker",
    "topic": "Stack",
    "difficulty": "Easy",
    "description": "Verify that ancient ceremonial symbols are properly balanced in temple inscriptions. Check for balanced parentheses, brackets, and braces to ensure ritual correctness.",
    "constraints": [
      "1 <= s.length <= 10^4"
    ],
    "examples": [
      {
        "input": "s = \"({[[]]})\"",
        "output": "true",
        "explanation": "All symbols are properly matched and balanced"
      }
    ],
    "hint": "Use stack to track opening symbols"
  },
  {
    "id": 85,
    "title": "Next Greater Artifact Finder",
    "topic": "Stack",
    "difficulty": "Medium",
    "description": "For each artifact in a temple collection, find the next greater artifact to its right. This helps priests identify ascending spiritual value patterns in ancient collections.",
    "constraints": [
      "1 <= n <= 10^5",
      "0 <= arr[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "arr = [4,5,2,10,8]",
        "output": "[5,10,10,-1,-1]",
        "explanation": "Next greater elements for each position"
      }
    ],
    "hint": "Use monotonic decreasing stack"
  },
  {
    "id": 86,
    "title": "Ritual Stack Sorter",
    "topic": "Stack",
    "difficulty": "Medium",
    "description": "Sort a stack of sacred scrolls using only stack operations. This helps temple librarians organize historical records in ascending order of spiritual significance.",
    "constraints": [
      "1 <= n <= 100"
    ],
    "examples": [
      {
        "input": "stack = [5,2,7,1,9]",
        "output": "[1,2,5,7,9]",
        "explanation": "Scrolls sorted in ascending order"
      }
    ],
    "hint": "Use temporary stack to maintain sorted order"
  },
  {
    "id": 87,
    "title": "Next Smaller Artifact Finder",
    "topic": "Stack",
    "difficulty": "Medium",
    "description": "For each artifact in a temple collection, find the next smaller artifact to its right. This helps identify descending spiritual value patterns in ancient collections.",
    "constraints": [
      "1 <= n <= 10^5",
      "0 <= arr[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "arr = [4,5,2,10,8]",
        "output": "[2,2,-1,8,-1]",
        "explanation": "Next smaller elements for each position"
      }
    ],
    "hint": "Use monotonic increasing stack"
  },
  {
    "id": 88,
    "title": "Temple Cache Manager (LRU)",
    "topic": "Design, Hash Table, Linked List",
    "difficulty": "Hard",
    "description": "Implement an LRU (Least Recently Used) cache for temple artifacts. This system prioritizes recently used sacred items while evicting least recently used ones when capacity is reached.",
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key <= 10^4",
      "0 <= value <= 10^5"
    ],
    "examples": [
      {
        "input": "Capacity=2, put(1,1), put(2,2), get(1), put(3,3), get(2)",
        "output": "[1,-1]",
        "explanation": "Key 2 was evicted as it was least recently used"
      }
    ],
    "hint": "Use hash map with doubly linked list"
  },
  {
    "id": 89,
    "title": "Sacred Cache Manager (LFU)",
    "topic": "Design, Hash Table, Linked List",
    "difficulty": "Hard",
    "description": "Implement an LFU (Least Frequently Used) cache for temple rituals. This system prioritizes frequently used ceremonial items while evicting least frequently used ones when capacity is reached.",
    "constraints": [
      "1 <= capacity <= 10^4",
      "0 <= key <= 10^5",
      "0 <= value <= 10^9"
    ],
    "examples": [
      {
        "input": "Capacity=2, put(1,1), put(2,2), get(1), put(3,3), get(2)",
        "output": "[1,-1]",
        "explanation": "Key 2 was evicted as it was least frequently used"
      }
    ],
    "hint": "Use multiple doubly linked lists by frequency"
  },
  {
    "id": 90,
    "title": "Temple Pillar Area Calculator",
    "topic": "Stack",
    "difficulty": "Hard",
    "description": "Find the largest rectangular area under a histogram of temple pillar heights. This helps architects determine the optimal layout for sacred structures.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "Largest rectangle between pillars 5 and 6 (area = 5×2 = 10)"
      }
    ],
    "hint": "Use monotonic increasing stack"
  },
  {
    "id": 91,
    "title": "Sacred Window Maximum Finder",
    "topic": "Queue, Deque",
    "difficulty": "Hard",
    "description": "Find the maximum element in every sliding window of sacred procession observations. This helps priests identify peak spiritual energy during ceremonies.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
        "output": "[3,3,5,5,6,7]",
        "explanation": "Maximums of each sliding window of size 3"
      }
    ],
    "hint": "Use deque to maintain candidates in decreasing order"
  },
  {
    "id": 92,
    "title": "Minimum Value Stack",
    "topic": "Stack, Design",
    "difficulty": "Medium",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. This helps temple accountants track both current and minimum values of sacred offerings.",
    "constraints": [
      "1 <= operations <= 10^4",
      "0 <= values <= 10^4"
    ],
    "examples": [
      {
        "input": "Push: [5,3,7], GetMin: []",
        "output": "3",
        "explanation": "Minimum value in stack is 3"
      }
    ],
    "hint": "Use two stacks or store pairs (value, current_min)"
  },
  {
    "id": 93,
    "title": "Rotten Offering Spreader",
    "topic": "BFS, Matrix",
    "difficulty": "Medium",
    "description": "Simulate the spread of rotten offerings in a temple storage grid. Calculate the minimum time required for all fresh offerings to become rotten using BFS, or return -1 if impossible.",
    "constraints": [
      "1 <= m, n <= 10",
      "0 <= grid[i][j] <= 1"
    ],
    "examples": [
      {
        "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4",
        "explanation": "It takes 4 time units for all to rot"
      }
    ],
    "hint": "Use multi-source BFS starting from all rotten offerings"
  },
  {
    "id": 94,
    "title": "Ritual Stock Span Calculator",
    "topic": "Stack",
    "difficulty": "Medium",
    "description": "Calculate the span of temple stock prices where span is the number of consecutive days before the current day when the price was less than or equal to current price. This helps predict ritual offering trends.",
    "constraints": [
      "1 <= n <= 10^5",
      "0 <= price <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [100,80,60,70,60,75,85]",
        "output": "[1,1,1,2,1,4,6]",
        "explanation": "Span for each day showing consecutive lower or equal prices"
      }
    ],
    "hint": "Use stack to store indices of previous higher prices"
  },
  {
    "id": 95,
    "title": "Window Minimum Maximizer",
    "topic": "Stack, Queue",
    "difficulty": "Hard",
    "description": "Find the maximum of the minimums of every window size in a sacred number sequence. This helps priests determine the optimal window size for ritual observations.",
    "constraints": [
      "1 <= n <= 10^5",
      "0 <= arr[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "arr = [10,20,30,50,10,70,30]",
        "output": "[70,30,20,10,10,10,10]",
        "explanation": "Maximum of minimums for each window size"
      }
    ],
    "hint": "Use stack to find next smaller elements and compute ranges"
  },
  {
    "id": 96,
    "title": "Temple Celebrity Identifier",
    "topic": "Stack, Two Pointers",
    "difficulty": "Medium",
    "description": "Identify the temple celebrity who knows no one but everyone knows them. Given a 2D matrix representing knowing relationships, find the celebrity in O(n) time.",
    "constraints": [
      "1 <= n <= 100"
    ],
    "examples": [
      {
        "input": "matrix = [[0,0,1,0],[0,0,1,0],[0,0,0,0],[0,0,1,0]]",
        "output": "2",
        "explanation": "Person 2 is known by all but knows no one"
      }
    ],
    "hint": "Use two pointers or stack to eliminate non-celebrities"
  },
  {
    "id": 97,
    "title": "Sacred Text Reverser",
    "topic": "String, Two Pointers",
    "difficulty": "Medium",
    "description": "Reverse the words in a sacred text while preserving whitespace and initial word order. This helps decode ancient prophecies written in reverse word sequences.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s contains English letters, digits, and spaces"
    ],
    "examples": [
      {
        "input": "s = \"the sky is blue\"",
        "output": "\"blue is sky the\"",
        "explanation": "Words reversed while maintaining order"
      }
    ],
    "hint": "Reverse entire string then reverse each word"
  },
  {
    "id": 98,
    "title": "Longest Sacred Palindrome Finder",
    "topic": "String, Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find the longest palindromic substring in ancient ceremonial texts. Palindromes hold special spiritual significance in temple traditions.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of English letters only"
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\" or \"aba\"",
        "explanation": "Both are valid longest palindromic substrings"
      }
    ],
    "hint": "Expand around center or use dynamic programming"
  },
  {
    "id": 99,
    "title": "Roman Numeral Converter",
    "topic": "String, Hash Table",
    "difficulty": "Easy",
    "description": "Convert between Roman numerals and integers for temple historical records. This helps decipher ancient dates and quantities recorded in Roman numeral system.",
    "constraints": [
      "1 <= roman.length <= 15",
      "1 <= integer <= 3999"
    ],
    "examples": [
      {
        "input": "roman = \"MCMXCIV\"",
        "output": "1994",
        "explanation": "M=1000, CM=900, XC=90, IV=4"
      }
    ],
    "hint": "Process from right to left, subtracting when smaller value precedes larger"
  },
  {
    "id": 100,
    "title": "Sacred Number String Converter",
    "topic": "String",
    "difficulty": "Medium",
    "description": "Implement ATOI to convert sacred text to numbers and STRSTR to find substrings in ceremonial texts. These functions help automate temple record processing.",
    "constraints": [
      "0 <= s.length <= 200",
      "s consists of English letters and digits"
    ],
    "examples": [
      {
        "input": "s = \" -42\"",
        "output": "-42",
        "explanation": "Convert string to integer ignoring leading whitespace"
      }
    ],
    "hint": "Handle edge cases: whitespace, signs, overflow"
  },
  {
    "id": 101,
    "title": "Common Temple Prefix Finder",
    "topic": "String",
    "difficulty": "Easy",
    "description": "Find the longest common prefix among an array of sacred texts. This helps identify shared beginnings of ritual chants and prayers.",
    "constraints": [
      "1 <= strs.length <= 200",
      "0 <= strs[i].length <= 200"
    ],
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\"",
        "explanation": "Common prefix among all strings is \"fl\""
      }
    ],
    "hint": "Compare character by character vertically"
  },
  {
    "id": 102,
    "title": "Sacred Text Pattern Matcher",
    "topic": "String, Rolling Hash",
    "difficulty": "Medium",
    "description": "Implement the Rabin-Karp algorithm to find patterns in ancient scriptures. This efficient string matching helps locate specific ritual sequences in voluminous sacred texts.",
    "constraints": [
      "1 <= text.length, pattern.length <= 10^4"
    ],
    "examples": [
      {
        "input": "text = \"ABABDABACDABABCABAB\", pattern = \"ABABCABAB\"",
        "output": "[10]",
        "explanation": "Pattern found starting at index 10"
      }
    ],
    "hint": "Use rolling hash to compare pattern with text substrings"
  },
  {
    "id": 103,
    "title": "Z-Function for Sacred Texts",
    "topic": "String",
    "difficulty": "Hard",
    "description": "Implement the Z-function to find all occurrences of a pattern in sacred texts. This advanced string algorithm helps priests quickly locate ritual sequences.",
    "constraints": [
      "1 <= text.length <= 10^5"
    ],
    "examples": [
      {
        "input": "text = \"aaabaab\"",
        "output": "[0,2,1,0,2,1,0]",
        "explanation": "Z-array values for the string"
      }
    ],
    "hint": "Maintain interval [L,R] with maximum prefix matching"
  },
  {
    "id": 104,
    "title": "Knuth-Morris-Pratt Ritual Matcher",
    "topic": "String",
    "difficulty": "Hard",
    "description": "Implement the KMP algorithm to efficiently find patterns in sacred texts using the LPS (Longest Prefix Suffix) array. This helps quickly locate ritual sequences for ceremonial preparation.",
    "constraints": [
      "1 <= text.length, pattern.length <= 10^4"
    ],
    "examples": [
      {
        "input": "pattern = \"ABABCABAB\"",
        "output": "[0,0,1,2,0,1,2,3,4]",
        "explanation": "LPS array for the pattern"
      }
    ],
    "hint": "Build LPS array then use it for efficient matching"
  },
  {
    "id": 105,
    "title": "Palindrome Creation Helper",
    "topic": "String",
    "difficulty": "Medium",
    "description": "Find the minimum characters needed to be inserted at the beginning of a sacred text to make it palindromic. This helps restore damaged ancient texts to their original palindromic form.",
    "constraints": [
      "1 <= s.length <= 10^3"
    ],
    "examples": [
      {
        "input": "s = \"abc\"",
        "output": "2",
        "explanation": "Need to add \"cb\" at beginning to make \"cbabc\""
      }
    ],
    "hint": "Find the longest palindromic prefix"
  },
  {
    "id": 106,
    "title": "Sacred Anagram Checker",
    "topic": "String, Hash Table",
    "difficulty": "Easy",
    "description": "Check if two sacred texts are anagrams of each other (contain the same characters in different orders). This verifies whether ritual chants are valid rearrangements of approved texts.",
    "constraints": [
      "1 <= s.length, t.length <= 5 * 10^4"
    ],
    "examples": [
      {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true",
        "explanation": "Both contain same characters with same frequencies"
      }
    ],
    "hint": "Use frequency array or sort both strings"
  },
  {
    "id": 107,
    "title": "Ritual Chant Generator",
    "topic": "String",
    "difficulty": "Medium",
    "description": "Generate the nth term of the Count and Say sequence used in temple chanting rituals. Each term describes the count of digits in the previous term.",
    "constraints": [
      "1 <= n <= 30"
    ],
    "examples": [
      {
        "input": "n = 4",
        "output": "\"1211\"",
        "explanation": "Sequence: 1, 11, 21, 1211, ..."
      }
    ],
    "hint": "Iteratively build each term from previous one"
  },
  {
    "id": 108,
    "title": "Sacred Version Comparator",
    "topic": "String",
    "difficulty": "Medium",
    "description": "Compare version numbers of ancient temple software used to manage ritual systems. This determines which version is newer for ceremonial updates.",
    "constraints": [
      "1 <= version1.length, version2.length <= 500"
    ],
    "examples": [
      {
        "input": "version1 = \"1.01\", version2 = \"1.001\"",
        "output": "0",
        "explanation": "Both versions are equal ignoring leading zeros"
      }
    ],
    "hint": "Split by dots and compare each revision numerically"
  },
  {
    "id": 109,
    "title": "Sacred Artifact Product Maximizer",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "As a temple merchant, find the contiguous subarray of sacred artifacts that yields the maximum product. This helps maximize the spiritual value of offerings during ceremonial trades.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [2,3,-2,4]",
        "output": "6",
        "explanation": "Subarray [2,3] has the largest product 6"
      }
    ],
    "hint": "Track both maximum and minimum products at each position"
  },
  {
    "id": 110,
    "title": "Ritual Sequence Lengthener",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find the longest increasing subsequence of sacred ritual steps. This helps priests preserve the optimal order of ceremonial actions for maximum spiritual efficacy.",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [10,9,2,5,3,7,101,18]",
        "output": "4",
        "explanation": "Longest increasing subsequence is [2,3,7,101] of length 4"
      }
    ],
    "hint": "Use DP with binary search for O(n log n) solution"
  },
  {
    "id": 111,
    "title": "Ancient Text Comparer",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find the longest common subsequence between two sacred texts from different temple archives. This reveals shared spiritual wisdom across historical traditions.",
    "constraints": [
      "1 <= text1.length, text2.length <= 1000"
    ],
    "examples": [
      {
        "input": "text1 = \"abcde\", text2 = \"ace\"",
        "output": "3",
        "explanation": "Longest common subsequence is \"ace\" of length 3"
      }
    ],
    "hint": "Use 2D DP table where dp[i][j] represents LCS of first i and j characters"
  },
  {
    "id": 112,
    "title": "Ceremonial Knapsack Packer",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Solve the 0-1 knapsack problem for sacred artifacts with given weights and values. Maximize spiritual value without exceeding the ceremonial altar's weight capacity.",
    "constraints": [
      "1 <= N <= 1000",
      "1 <= W <= 1000",
      "1 <= wt[i], val[i] <= 1000"
    ],
    "examples": [
      {
        "input": "W = 4, wt = [1,2,3], val = [10,15,40]",
        "output": "55",
        "explanation": "Take items 1 and 3: value 10 + 40 = 55, weight 1 + 3 = 4"
      }
    ],
    "hint": "Use DP table where dp[i][w] represents max value with first i items and capacity w"
  },
  {
    "id": 113,
    "title": "Sacred Text Editor",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find the minimum edit distance between two sacred texts (number of insertions, deletions, or substitutions required to make them identical). This helps scribes correct errors in ancient manuscripts.",
    "constraints": [
      "0 <= word1.length, word2.length <= 500"
    ],
    "examples": [
      {
        "input": "word1 = \"horse\", word2 = \"ros\"",
        "output": "3",
        "explanation": "horse -> rorse -> rose -> ros (3 operations)"
      }
    ],
    "hint": "Use DP where dp[i][j] represents edit distance between first i and j characters"
  },
  {
    "id": 114,
    "title": "Increasing Offering Value Maximizer",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find the maximum sum increasing subsequence of ceremonial offerings. This helps priests select the most valuable sequence of offerings while maintaining ascending spiritual value.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "1 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1,101,2,3,100,4,5]",
        "output": "106",
        "explanation": "Maximum sum increasing subsequence is [1,2,3,100] with sum 106"
      }
    ],
    "hint": "Modify LIS DP to track sum instead of length"
  },
  {
    "id": 115,
    "title": "Ritual Matrix Multiplier",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "description": "Find the most efficient way to multiply ceremonial matrices in the correct order. This minimizes the computational effort required for complex temple calculations.",
    "constraints": [
      "2 <= N <= 100",
      "1 <= dimensions[i] <= 100"
    ],
    "examples": [
      {
        "input": "dims = [40,20,30,10,30]",
        "output": "26000",
        "explanation": "Optimal parenthesization: (A(BC))D with 26000 multiplications"
      }
    ],
    "hint": "Use DP where dp[i][j] represents min operations to multiply matrices from i to j"
  },
  {
    "id": 116,
    "title": "Temple Pathfinder",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find the minimum sum path through a matrix of sacred numbers from top-left to bottom-right. This helps pilgrims find the most spiritually efficient path through temple grounds.",
    "constraints": [
      "m == grid.length, n == grid[i].length",
      "1 <= m, n <= 200",
      "0 <= grid[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "Path 1→3→1→1→1 has minimum sum 7"
      }
    ],
    "hint": "Use DP where dp[i][j] represents min sum to reach cell (i,j)"
  },
  {
    "id": 117,
    "title": "Ceremonial Coin Changer",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find the number of ways to make change for a sacred amount using temple coins of different denominations. This helps priests prepare exact ceremonial offerings.",
    "constraints": [
      "1 <= amount <= 5000",
      "1 <= coins.length <= 300",
      "1 <= coins[i] <= 5000"
    ],
    "examples": [
      {
        "input": "amount = 5, coins = [1,2,5]",
        "output": "4",
        "explanation": "Ways: 5=5, 5=2+2+1, 5=2+1+1+1, 5=1+1+1+1+1"
      }
    ],
    "hint": "Use DP where dp[i] represents ways to make amount i"
  },
  {
    "id": 118,
    "title": "Sacred Subset Sum Finder",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Determine if there exists a subset of sacred numbers that sums to a target value. This helps identify combinations of offerings that match specific ceremonial requirements.",
    "constraints": [
      "1 <= N <= 100",
      "1 <= sum <= 1000",
      "0 <= arr[i] <= 1000"
    ],
    "examples": [
      {
        "input": "arr = [3,34,4,12,5,2], sum = 9",
        "output": "true",
        "explanation": "Subset [4,5] sums to 9"
      }
    ],
    "hint": "Use DP where dp[i][j] represents if sum j can be achieved with first i elements"
  },
  {
    "id": 119,
    "title": "Ritual Rod Cutter",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find the maximum value obtainable by cutting a sacred rod of length n into pieces with given values. This helps optimize the use of ceremonial materials.",
    "constraints": [
      "1 <= n <= 1000",
      "1 <= price[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "n = 8, price = [1,5,8,9,10,17,17,20]",
        "output": "22",
        "explanation": "Cut into lengths 2 and 6: value 5 + 17 = 22"
      }
    ],
    "hint": "Use DP where dp[i] represents max value for rod of length i"
  },
  {
    "id": 120,
    "title": "Sacred Egg Dropper",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "description": "Find the minimum number of attempts needed to determine the highest floor from which a sacred egg can be dropped without breaking. This preserves fragile ceremonial objects.",
    "constraints": [
      "1 <= k <= 100 (eggs)",
      "1 <= n <= 10000 (floors)"
    ],
    "examples": [
      {
        "input": "k = 2, n = 10",
        "output": "4",
        "explanation": "Minimum 4 attempts needed to find critical floor with 2 eggs and 10 floors"
      }
    ],
    "hint": "Use DP where dp[i][j] represents min attempts with i eggs and j floors"
  },
  {
    "id": 121,
    "title": "Ceremonial Text Breaker",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Determine if a sacred text can be segmented into space-separated words from a temple dictionary. This helps validate the structure of ritual incantations.",
    "constraints": [
      "1 <= s.length <= 300",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 20"
    ],
    "examples": [
      {
        "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
        "output": "true",
        "explanation": "Text can be segmented as \"leet code\""
      }
    ],
    "hint": "Use DP where dp[i] represents if first i characters can be segmented"
  },
  {
    "id": 122,
    "title": "Palindrome Partition Optimizer",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "description": "Find the minimum cuts needed to partition a sacred text such that every substring is a palindrome. This optimizes the preparation of ritual texts for ceremonial chanting.",
    "constraints": [
      "1 <= s.length <= 2000"
    ],
    "examples": [
      {
        "input": "s = \"aab\"",
        "output": "1",
        "explanation": "Partition into [\"aa\",\"b\"] with 1 cut"
      }
    ],
    "hint": "Use DP with palindrome precomputation"
  },
  {
    "id": 123,
    "title": "Ritual Job Scheduler",
    "topic": "Dynamic Programming, Binary Search",
    "difficulty": "Hard",
    "description": "Schedule ceremonial jobs with start time, end time, and profit to maximize total spiritual gain. This helps priests optimize temple activities for maximum benefit.",
    "constraints": [
      "1 <= startTime.length == endTime.length == profit.length <= 5 * 10^4",
      "1 <= startTime[i] < endTime[i] <= 10^9",
      "1 <= profit[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]",
        "output": "120",
        "explanation": "Take jobs 1 and 4: profit 50 + 70 = 120"
      }
    ],
    "hint": "Sort by end time and use DP with binary search to find compatible jobs"
  }
]