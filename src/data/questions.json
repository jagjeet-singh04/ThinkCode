[
  {
    "id": 1,
    "title": "Lily's Number Pair Hunt",
    "topic": "Array, Hash Table",
    "difficulty": "Easy",
    "description": "Lily has embarked on a magical adventure through the Enchanted Forest of Numbers, where she carries a scroll containing a list of mystical numbers. She has been given a special 'target' magic number by the Forest Guardian. Your quest is to help Lily find two distinct numbers in her list that, when combined through ancient arithmetic magic, sum up to exactly the target value. Return the indices of these two numbers, as the Forest Guardian requires their positions to unlock the next stage of her journey.",
    "constraints": [
      "2 <= numbers.length <= 10^4",
      "-10^9 <= numbers[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists"
    ],
    "examples": [
      {
        "input": "numbers = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because numbers[0] + numbers[1] == 9, we return [0, 1]."
      },
      {
        "input": "numbers = [3,4,2], target = 6",
        "output": "[1,2]",
        "explanation": "Because numbers[1] + numbers[2] == 6, we return [1, 2]."
      }
    ],
    "hint": "Original: Two Sum"
  },
  {
    "id": 2,
    "title": "Number Reverser Machine",
    "topic": "Math",
    "difficulty": "Medium",
    "description": "Tom the Tinkerer has invented a marvelous machine that can reverse the digits of any integer. However, his machine has a peculiar limitation - if reversing the number causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], the machine malfunctions and returns 0 instead. Tom needs your help to ensure his machine operates correctly. Given an integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range, return 0.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321"
      },
      {
        "input": "x = -150",
        "output": "-51"
      },
      {
        "input": "x = 1534236469",
        "output": "0",
        "explanation": "The reverse of 1534236469 is 9646324351, which is greater than 2^31 - 1 (2147483647), so we return 0."
      }
    ],
    "hint": "Original: Reverse Integer"
  },
  {
    "id": 3,
    "title": "Water Container Challenge",
    "topic": "Array, Two Pointers, Greedy",
    "difficulty": "Medium",
    "description": "You are an architect designing a revolutionary water containment system for a futuristic city. The city has n vertical walls of different heights arranged in a line. Each wall is represented by an integer array where each element represents the height of a wall. Your task is to find two walls that, together with the ground, can form a container that holds the maximum amount of water. Return the maximum amount of water that can be stored between any two walls in the system. Note: You may not slant the container.",
    "constraints": [
      "n == heights.length",
      "2 <= n <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The walls at positions 1 (height 8) and 8 (height 7) form the largest container. The area is calculated as min(8, 7) * (8-1) = 7 * 7 = 49."
      },
      {
        "input": "heights = [5,3,2,1,4]",
        "output": "16",
        "explanation": "The walls at positions 0 (height 5) and 4 (height 4) form the largest container. The area is calculated as min(5, 4) * (4-0) = 4 * 4 = 16."
      }
    ],
    "hint": "Original: Container With Most Water"
  },
  {
    "id": 4,
    "title": "Middle Value Finder",
    "topic": "Array, Binary Search, Divide and Conquer",
    "difficulty": "Hard",
    "description": "As a data analyst at a major research facility, you've been tasked with merging two sorted datasets and finding the median value of the combined dataset. The median is the middle value in an ordered integer list. If the size of the list is even, there is no single middle value, so the median is the mean of the two middle values. Implement a function that finds the median of the two sorted arrays with an overall runtime complexity of O(log (m+n)).",
    "constraints": [
      "nums1.length == m",
      "nums2.length == n",
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1,3], nums2 = [2]",
        "output": "2.00000",
        "explanation": "The merged array is [1,2,3] and the median is 2."
      },
      {
        "input": "nums1 = [1,2], nums2 = [3,4]",
        "output": "2.50000",
        "explanation": "The merged array is [1,2,3,4] and the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "hint": "Original: Median of Two Sorted Arrays"
  },
  {
    "id": 5,
    "title": "Palindrome Hunter",
    "topic": "String, Dynamic Programming",
    "difficulty": "Medium",
    "description": "You are an archaeologist deciphering ancient texts. In these texts, palindromic sequences hold special power. A palindrome is a word that reads the same forward and backward. Your mission is to find the longest palindromic substring in a given string of ancient script. This discovery could unlock secrets of a lost civilization and reveal powerful artifacts hidden for millennia.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only digits (0-9), English letters (a-z, A-Z), and no other characters"
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "\"bab\" is a valid palindrome (\"aba\" is also a valid answer)."
      },
      {
        "input": "s = \"racecar\"",
        "output": "\"racecar\"",
        "explanation": "The entire string is a palindrome."
      }
    ],
    "hint": "Original: Longest Palindromic Substring"
  },
  {
    "id": 6,
    "title": "Light Grid Controller",
    "topic": "Array, Hash Table, Matrix",
    "difficulty": "Medium",
    "description": "You are the chief engineer of a futuristic city's lighting grid system. The grid is represented by an m x n matrix. Each cell in the grid represents a smart light that can be either on (represented by 1) or off (represented by 0). Due to a newly discovered energy conservation protocol, if any light is found to be off, you must turn off all lights in its entire row and column to prevent power drainage. Your task is to modify the grid in place according to this new protocol while maintaining optimal energy efficiency.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 200",
      "-2^31 <= grid[i][j] <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "grid = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The center light is off, so its entire row and column are turned off."
      },
      {
        "input": "grid = [[0,1,2],[3,4,5]]",
        "output": "[[0,0,0],[0,4,5]]",
        "explanation": "The top-left light is off, so the first row and first column are turned off."
      }
    ],
    "hint": "Original: Set Matrix Zeros"
  },
  {
    "id": 7,
    "title": "Number Pyramid Builder",
    "topic": "Array, Dynamic Programming",
    "difficulty": "Easy",
    "description": "You are a mathematician exploring the ancient numerical pyramid patterns discovered in an archaeological dig. This special pyramid, known as Pascal's Triangle, has each number being the sum of the two numbers directly above it. The pyramid starts with a single '1' at the apex, and each subsequent row begins and ends with '1'. Your task is to reconstruct the first numRows of this mystical numerical pyramid to unlock its mathematical secrets.",
    "constraints": [
      "1 <= numRows <= 30"
    ],
    "examples": [
      {
        "input": "numRows = 5",
        "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
        "explanation": "The pyramid has 5 rows as constructed according to Pascal's Triangle rules."
      },
      {
        "input": "numRows = 3",
        "output": "[[1],[1,1],[1,2,1]]",
        "explanation": "The pyramid has 3 rows following the pattern."
      }
    ],
    "hint": "Original: Pascal's Triangle"
  },
  {
    "id": 8,
    "title": "Next Number Sequence Finder",
    "topic": "Array, Two Pointers",
    "difficulty": "Medium",
    "description": "As a cryptographer working with numerical codes, you've discovered that certain sequences have a natural ordering. Given a sequence of distinct integers, your task is to find the next permutation of numbers that is lexicographically greater than the given sequence. If no such permutation exists (meaning the sequence is already at the highest possible order), rearrange it to the lowest possible order (sorted in ascending order). You must modify the array in-place with O(1) extra memory.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[1,3,2]",
        "explanation": "The next lexicographically greater permutation of [1,2,3] is [1,3,2]."
      },
      {
        "input": "nums = [3,2,1]",
        "output": "[1,2,3]",
        "explanation": "No greater permutation exists, so return the smallest permutation."
      }
    ],
    "hint": "Original: Next Permutation"
  },
  {
    "id": 9,
    "title": "Maximum Sum Subarray Finder",
    "topic": "Array, Divide and Conquer, Dynamic Programming",
    "difficulty": "Easy",
    "description": "As a financial analyst, you're analyzing daily profit/loss data to identify the most profitable continuous period for investment. Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. This will help identify the optimal investment window for maximum returns.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum of 6."
      },
      {
        "input": "nums = [1,2,3,-2,5]",
        "output": "9",
        "explanation": "The entire array has the largest sum of 9."
      }
    ],
    "hint": "Original: Kadane's Algorithm"
  },
  {
    "id": 10,
    "title": "Color Sorter",
    "topic": "Array, Two Pointers, Sorting",
    "difficulty": "Medium",
    "description": "You're working in a factory that produces colored balls (red=0, white=1, blue=2). The balls come off the production line in random order, but they need to be sorted so that all red balls come first, followed by white balls, and then blue balls. Due to space constraints, you must sort the balls in-place without using extra space. This is a variation of the famous Dutch National Flag problem.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is 0, 1, or 2"
    ],
    "examples": [
      {
        "input": "nums = [2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": "Sorted order: red, red, white, white, blue, blue."
      },
      {
        "input": "nums = [1,0,2]",
        "output": "[0,1,2]",
        "explanation": "Sorted order: red, white, blue."
      }
    ],
    "hint": "Original: Sort an array of 0's, 1's and 2's"
  },
  {
    "id": 11,
    "title": "Stock Market Profit Finder",
    "topic": "Array, Dynamic Programming",
    "difficulty": "Easy",
    "description": "As a stock market analyst, you're given historical prices of a stock where prices[i] is the price on the i-th day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = [10,20,30]",
        "output": "20",
        "explanation": "Buy on day 1 (price = 10) and sell on day 3 (price = 30), profit = 20."
      }
    ],
    "hint": "Original: Stock Buy and Sell"
  },
  {
    "id": 12,
    "title": "Grid Rotator",
    "topic": "Array, Math, Matrix",
    "difficulty": "Medium",
    "description": "You are developing image processing software that needs to rotate images by 90 degrees clockwise. The image is represented by an n × n 2D matrix where each element represents a pixel. Your task is to rotate the image in-place, which means you have to modify the input 2D matrix directly without allocating another 2D matrix.",
    "constraints": [
      "n == matrix.length == matrix[i].length",
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "The matrix rotated 90 degrees clockwise."
      },
      {
        "input": "matrix = [[1,2],[3,4]]",
        "output": "[[3,1],[4,2]]",
        "explanation": "The matrix rotated 90 degrees clockwise."
      }
    ],
    "hint": "Original: Rotate Matrix"
  },
  {
    "id": 13,
    "title": "Interval Merger",
    "topic": "Array, Sorting",
    "difficulty": "Medium",
    "description": "As a scheduling coordinator for a large conference center, you're given an array of intervals where intervals[i] = [start_i, end_i] represents meeting times. Your task is to merge all overlapping intervals and return an array of the non-overlapping intervals that cover all meetings in the input. This will help optimize room utilization and prevent scheduling conflicts.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= start_i <= end_i <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Intervals [1,3] and [2,6] overlap, so they are merged into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] are considered overlapping and are merged."
      }
    ],
    "hint": "Original: Merge Overlapping Subintervals"
  },
  {
    "id": 14,
    "title": "Sorted List Merger",
    "topic": "Array, Two Pointers, Sorting",
    "difficulty": "Medium",
    "description": "You're working with memory-constrained embedded systems that need to merge two sorted arrays. Given two sorted integer arrays nums1 and nums2, and integers m and n representing the number of elements in nums1 and nums2 respectively, merge nums2 into nums1 as one sorted array without using extra space. nums1 has a length of m + n, where the first m elements are the actual elements and the last n elements are set to 0 and should be ignored.",
    "constraints": [
      "nums1.length == m + n",
      "nums2.length == n",
      "0 <= m, n <= 10^5",
      "1 <= m + n <= 10^5",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1,3,5,0,0,0], m = 3, nums2 = [2,4,6], n = 3",
        "output": "[1,2,3,4,5,6]",
        "explanation": "The arrays are merged into nums1 as a sorted array."
      },
      {
        "input": "nums1 = [1,2,0,0], m = 2, nums2 = [3,4], n = 2",
        "output": "[1,2,3,4]",
        "explanation": "The arrays are merged into nums1."
      }
    ],
    "hint": "Original: Merge two sorted arrays without extra space"
  },
  {
    "id": 15,
    "title": "Duplicate Number Finder",
    "topic": "Array, Two Pointers, Binary Search",
    "difficulty": "Medium",
    "description": "You're a detective investigating a case where an array of n + 1 integers contains numbers in the range [1, n] inclusive. There is exactly one repeated number, but you don't know how many times it appears. Your challenge is to find this duplicate number without modifying the array and using only constant extra space O(1), as the evidence must remain untouched for the court case.",
    "constraints": [
      "1 <= n <= 10^5",
      "nums.length == n + 1",
      "1 <= nums[i] <= n"
    ],
    "examples": [
      {
        "input": "nums = [1,3,4,2,2]",
        "output": "2",
        "explanation": "2 is the duplicate number in the array."
      },
      {
        "input": "nums = [3,1,3,4,2]",
        "output": "3",
        "explanation": "3 is the duplicate number in the array."
      }
    ],
    "hint": "Original: Find the duplicate in an array of N+1 integers"
  },
  {
    "id": 16,
    "title": "Missing and Repeated Number Finder",
    "topic": "Array, Hash Table, Math",
    "difficulty": "Medium",
    "description": "As a quality control inspector at a number factory, you've discovered that in an array of size n containing integers from 1 to n, one number is missing and another number is duplicated. Your task is to find both the missing number and the duplicated number efficiently to correct the production error and maintain quality standards.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "1 <= nums[i] <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [3,1,2,5,3]",
        "output": "[3,4]",
        "explanation": "3 is repeated and 4 is missing."
      },
      {
        "input": "nums = [1,2,2,4]",
        "output": "[2,3]",
        "explanation": "2 is repeated and 3 is missing."
      }
    ],
    "hint": "Original: Repeat and Missing Number"
  },
  {
    "id": 17,
    "title": "Out-of-Order Pair Counter",
    "topic": "Array, Binary Search, Divide and Conquer, Sorting",
    "difficulty": "Medium",
    "description": "As a data quality analyst, you need to measure how unsorted an array is by counting inversion pairs. Given an array of integers, count the number of inversions where an inversion is defined as a pair of indices (i, j) such that i < j and nums[i] > nums[j]. This measurement helps quantify how much work would be needed to sort the array completely.",
    "constraints": [
      "1 <= nums.length <= 5 * 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2,4,1,3,5]",
        "output": "3",
        "explanation": "The inversion pairs are (2,1), (4,1), and (4,3)."
      },
      {
        "input": "nums = [5,4,3,2,1]",
        "output": "10",
        "explanation": "Every pair is an inversion: total pairs = n(n-1)/2 = 10."
      }
    ],
    "hint": "Original: Inversion of Array"
  },
  {
    "id": 18,
    "title": "Grid Number Searcher",
    "topic": "Array, Binary Search, Matrix",
    "difficulty": "Medium",
    "description": "You're developing a search algorithm for a special sorted matrix where each row is sorted in non-decreasing order, and the first integer of each row is greater than the last integer of the previous row. Given a target integer, return true if target is in the matrix or false otherwise. Your solution must run in O(log(m * n)) time complexity to efficiently handle large datasets.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^9 <= matrix[i][j], target <= 10^9"
    ],
    "examples": [
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
        "output": "true",
        "explanation": "3 exists in the matrix."
      },
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
        "output": "false",
        "explanation": "13 does not exist in the matrix."
      }
    ],
    "hint": "Original: Search in a 2D matrix"
  },
  {
    "id": 19,
    "title": "Power Calculator",
    "topic": "Math, Recursion",
    "difficulty": "Medium",
    "description": "You're building a scientific calculator that needs to efficiently compute x raised to the power n (x^n). Implement a fast power function that handles both positive and negative exponents efficiently using logarithmic time complexity. This is crucial for your calculator to perform well with very large exponents.",
    "constraints": [
      "-100.0 < x < 100.0",
      "-2^31 <= n <= 2^31-1",
      "n is an integer",
      "Either x is not zero or n > 0",
      "-10^4 <= x^n <= 10^4"
    ],
    "examples": [
      {
        "input": "x = 2.00000, n = 10",
        "output": "1024.00000",
        "explanation": "2^10 = 1024."
      },
      {
        "input": "x = 3.00000, n = 3",
        "output": "27.00000",
        "explanation": "3^3 = 27."
      },
      {
        "input": "x = 2.00000, n = -2",
        "output": "0.25000",
        "explanation": "2^-2 = 1/4 = 0.25."
      }
    ],
    "hint": "Original: Pow(x, n)"
  },
  {
    "id": 20,
    "title": "Majority Element Finder",
    "topic": "Array, Hash Table, Divide and Conquer",
    "difficulty": "Easy",
    "description": "As an election analyst, you need to determine if any candidate has received the majority of votes (more than n/2 votes). Given an array nums of size n, return the majority element that appears more than ⌊n/2⌋ times. You may assume that the majority element always exists in the array, making your analysis straightforward.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 5 * 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3,2,3]",
        "output": "3",
        "explanation": "3 appears 2 out of 3 times, which is more than n/2."
      },
      {
        "input": "nums = [1,1,2]",
        "output": "1",
        "explanation": "1 appears 2 out of 3 times, which is more than n/2."
      }
    ],
    "hint": "Original: Majority Element (>n/2 times)"
  },
  {
    "id": 21,
    "title": "Frequent Element Finder",
    "topic": "Array, Hash Table",
    "difficulty": "Medium",
    "description": "In a political analysis scenario, you need to identify all elements that appear more than ⌊n/3⌋ times in an array. These represent significant minority positions that could form coalitions. Given an integer array of size n, find all elements that appear more than ⌊n/3⌋ times, as these could be potential coalition builders in a multi-party system.",
    "constraints": [
      "1 <= nums.length <= 5 * 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3,2,3]",
        "output": "[3]",
        "explanation": "3 appears 2 out of 3 times, which is more than ⌊3/3⌋ = 1."
      },
      {
        "input": "nums = [1,2,3,1,2]",
        "output": "[1,2]",
        "explanation": "1 and 2 each appear 2 out of 5 times, which is more than ⌊5/3⌋ ≈ 1.67."
      }
    ],
    "hint": "Original: Majority Element (n/3 times)"
  },
  {
    "id": 22,
    "title": "Robot Path Counter",
    "topic": "Math, Dynamic Programming, Combinatorics",
    "difficulty": "Medium",
    "description": "You're programming a robot that starts in the top-left corner of an m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there? This problem helps in pathfinding algorithms for autonomous robots in constrained environments.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 possible unique paths from top-left to bottom-right."
      },
      {
        "input": "m = 2, n = 2",
        "output": "2",
        "explanation": "Two possible paths: right-down or down-right."
      }
    ],
    "hint": "Original: Grid Unique Paths"
  },
  {
    "id": 23,
    "title": "Double Reverse Pair Counter",
    "topic": "Array, Binary Search, Divide and Conquer",
    "difficulty": "Hard",
    "description": "In a financial analysis system, you need to identify significant price discrepancies. Given an array nums, return the number of reverse pairs where a reverse pair is a pair (i, j) where i < j and nums[i] > 2 * nums[j]. This helps identify extreme market anomalies that could indicate trading opportunities or market manipulation.",
    "constraints": [
      "1 <= nums.length <= 5 * 10^4",
      "-2^31 <= nums[i] <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "nums = [1,3,2,3,1]",
        "output": "2",
        "explanation": "The reverse pairs are (3,1) and (3,1) where 3 > 2*1."
      },
      {
        "input": "nums = [5,2,3]",
        "output": "1",
        "explanation": "The reverse pair is (5,2) where 5 > 2*2."
      }
    ],
    "hint": "Original: Reverse Pairs"
  },
  {
    "id": 24,
    "title": "Number Pair Sum Hunter",
    "topic": "Array, Hash Table",
    "difficulty": "Easy",
    "description": "In a treasure hunting game, you're given a list of numbers and a target sum. Your quest is to find two different numbers in the list that add up to the target sum. Return the indices of these two numbers. You may assume that each input would have exactly one solution, and you may not use the same element twice, as each treasure can only be used once in the combination.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists"
    ],
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "hint": "Original: 2Sum Problem"
  },
  {
    "id": 25,
    "title": "Four Number Sum Finder",
    "topic": "Array, Two Pointers, Sorting",
    "difficulty": "Medium",
    "description": "As a cryptanalyst, you're trying to break a four-number combination lock. Given an array nums of n integers and a target value, find all unique quadruplets in the array which gives the sum of target. Each quadruplet must contain distinct elements from the array, and the solution set must not contain duplicate quadruplets.",
    "constraints": [
      "1 <= nums.length <= 200",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1,0,-1,0,-2,2], target = 0",
        "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
        "explanation": "These are the unique quadruplets that sum to 0."
      },
      {
        "input": "nums = [1,2,3,4], target = 10",
        "output": "[[1,2,3,4]]",
        "explanation": "The only quadruplet that sums to 10."
      }
    ],
    "hint": "Original: 4-Sum Problem"
  },
  {
    "id": 26,
    "title": "Longest Number Chain Finder",
    "topic": "Array, Hash Table, Union Find",
    "difficulty": "Medium",
    "description": "As a genealogist studying numerical family trees, you want to find the longest sequence of consecutive numbers in an unsorted array of integers. For example, in the array [100, 4, 200, 1, 3, 2], the longest consecutive elements sequence is [1, 2, 3, 4]. Return the length of this sequence. Your algorithm should run in O(n) time complexity to handle large family trees efficiently.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100,4,200,1,3,2]",
        "output": "4",
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4] with length 4."
      },
      {
        "input": "nums = [5,1,3]",
        "output": "1",
        "explanation": "There are no consecutive sequences longer than 1."
      }
    ],
    "hint": "Original: Longest Consecutive Sequence"
  },
  {
    "id": 27,
    "title": "Subarray Sum Finder",
    "topic": "Array, Hash Table",
    "difficulty": "Medium",
    "description": "As a data analyst, you're looking for the longest contiguous subarray that sums to exactly k. Given an integer array nums and an integer k, return the maximum length of a contiguous subarray that sums to k. If there is no such subarray, return 0. This helps identify significant patterns in time-series data.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1,-1,5,-2,3], k = 3",
        "output": "4",
        "explanation": "The subarray [1,-1,5,-2] sums to 3 and has length 4."
      },
      {
        "input": "nums = [1,2,3], k = 6",
        "output": "3",
        "explanation": "The entire array sums to 6."
      }
    ],
    "hint": "Original: Largest Subarray with K sum"
  },
  {
    "id": 28,
    "title": "XOR Subarray Counter",
    "topic": "Array, Hash Table, Bit Manipulation",
    "difficulty": "Medium",
    "description": "In a cryptographic analysis task, you need to count the number of contiguous subarrays where the XOR of all elements equals k. Given an array of integers nums and an integer k, return the number of contiguous subarrays where the XOR of all the elements in the subarray is k. This helps identify patterns in encrypted data streams.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^6",
      "0 <= k <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [4,2,2,6,4], k = 6",
        "output": "4",
        "explanation": "The subarrays with XOR 6 are [4,2], [4,2,2,6], [2,2,6], [6]."
      },
      {
        "input": "nums = [1,2,3], k = 3",
        "output": "2",
        "explanation": "The subarrays with XOR 3 are [3] and [1,2]."
      }
    ],
    "hint": "Original: Count number of subarrays with given xor K"
  },
  {
    "id": 29,
    "title": "Ancient Text Pattern Analyzer",
    "topic": "Hash Table, String, Sliding Window",
    "difficulty": "Medium",
    "description": "As a linguist studying ancient texts, you want to find the longest substring without repeating characters. Given a string s, find the length of the longest substring without repeating characters. This helps identify unique patterns in ancient languages that could reveal hidden meanings or grammatical structures.",
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "hint": "Use a sliding window approach with a hash set to track characters"
  },
  {
    "id": 30,
    "title": "Network Packet Reversal System",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "As a network engineer, you're designing a packet reassembly system where data packets arrive in reverse order. Reverse a singly linked list to reconstruct the original data stream. Given the head of a linked list, reverse it and return the new head.",
    "constraints": [
      "Number of nodes in the list is in the range [0, 5000]",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "explanation": "The reversed list shows packets in correct order"
      }
    ],
    "hint": "Use three pointers: previous, current, and next"
  },
  {
    "id": 31,
    "title": "Data Stream Middle Monitor",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "As a data analyst monitoring real-time streams, you need to find the middle element of a linked list. If there are two middle nodes, return the second one. This helps in balancing data processing loads.",
    "constraints": [
      "1 <= Number of nodes <= 100",
      "1 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[3,4,5]",
        "explanation": "Middle node is 3"
      }
    ],
    "hint": "Use slow and fast pointer technique"
  },
  {
    "id": 32,
    "title": "Sorted Data Merger",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "As a database administrator, you need to merge two sorted linked lists from different tables. Return a new sorted list by splicing together the nodes of the first two lists, preserving order.",
    "constraints": [
      "Number of nodes in both lists is in range [0, 50]",
      "-100 <= Node.val <= 100",
      "Both lists are sorted in non-decreasing order"
    ],
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "Merged while maintaining sorted order"
      }
    ],
    "hint": "Use dummy node to handle edge cases"
  },
  {
    "id": 33,
    "title": "Network Node Remover",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a security engineer, you need to remove the nth node from the end of a network node chain. This helps isolate compromised nodes while maintaining chain integrity.",
    "constraints": [
      "1 <= Number of nodes <= 30",
      "1 <= n <= Number of nodes"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], n = 2",
        "output": "[1,2,3,5]",
        "explanation": "Second node from end (value 4) is removed"
      }
    ],
    "hint": "Use two pointers with n node gap"
  },
  {
    "id": 34,
    "title": "Encrypted Number Adder",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a cryptographer, you're working with numbers stored as reversed linked lists. Add two numbers where each digit is stored in a node (reverse order) and return the sum as a linked list.",
    "constraints": [
      "Number of nodes in each list is in range [1, 100]",
      "0 <= Node.val <= 9",
      "Numbers don't contain leading zeros"
    ],
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807"
      }
    ],
    "hint": "Handle carry-over and different list lengths"
  },
  {
    "id": 35,
    "title": "Secure Node Deletion",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a system architect, you need to delete a node from a linked list given only access to that node. Implement an O(1) solution that preserves data integrity without accessing previous nodes.",
    "constraints": [
      "Number of nodes in list >= 2",
      "Node.val is unique",
      "Given node is not the tail node"
    ],
    "examples": [
      {
        "input": "node = 3 from [1,2,3,4]",
        "output": "[1,2,4]",
        "explanation": "Node 3 is replaced with node 4's value"
      }
    ],
    "hint": "Copy next node's value and skip next node"
  },
  {
    "id": 36,
    "title": "Network Intersection Locator",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "As a network investigator, find where two linked lists intersect in a Y-shaped configuration. This helps identify shared infrastructure nodes between two networks.",
    "constraints": [
      "Number of nodes in lists are in range [1, 1000]",
      "Node values are unique",
      "No cycles in either list"
    ],
    "examples": [
      {
        "input": "listA = [1,2,3,4], listB = [7,8,3,4]",
        "output": "Node with value 3",
        "explanation": "Lists intersect at node with value 3"
      }
    ],
    "hint": "Traverse both lists to find common node"
  },
  {
    "id": 37,
    "title": "Data Cycle Detector",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a data quality engineer, detect if a linked list has a cycle where some node points to a previous node. This helps identify infinite loops in data processing pipelines.",
    "constraints": [
      "Number of nodes in range [0, 1000]",
      "Node values are unique"
    ],
    "examples": [
      {
        "input": "head = [3,2,0,-4] with pos=1",
        "output": "true",
        "explanation": "Tail connects to second node"
      }
    ],
    "hint": "Use Floyd's cycle detection algorithm"
  },
  {
    "id": 38,
    "title": "Batch Data Reverser",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a data processor, reverse nodes in k-group batches in a linked list. If nodes aren't divisible by k, leave them as-is. This helps in batch processing optimization.",
    "constraints": [
      "Number of nodes in range [0, 1000]",
      "1 <= k <= number of nodes"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 3",
        "output": "[3,2,1,4,5]",
        "explanation": "First 3 nodes reversed, rest unchanged"
      }
    ],
    "hint": "Use recursion or iterative group reversal"
  },
  {
    "id": 39,
    "title": "Data Palindrome Validator",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "As a data integrity specialist, check if a linked list is a palindrome when read forward and backward. This verifies data symmetry in storage systems.",
    "constraints": [
      "Number of nodes in range [1, 1000]",
      "0 <= Node.val <= 9"
    ],
    "examples": [
      {
        "input": "head = [1,2,2,1]",
        "output": "true",
        "explanation": "List reads same forwards and backwards"
      }
    ],
    "hint": "Find middle, reverse second half, and compare"
  },
  {
    "id": 40,
    "title": "Cycle Origin Finder",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a system diagnostician, find the starting node of a cycle in a linked list. This helps pinpoint the exact location of infinite loops in processing systems.",
    "constraints": [
      "Number of nodes in range [1, 1000]",
      "Node values are unique"
    ],
    "examples": [
      {
        "input": "head = [3,2,0,-4] with pos=1",
        "output": "Node with value 2",
        "explanation": "Cycle starts at second node"
      }
    ],
    "hint": "Use Floyd's algorithm after cycle detection"
  },
  {
    "id": 41,
    "title": "Multi-level Data Flattener",
    "topic": "Linked List",
    "difficulty": "Hard",
    "description": "As a data architect, flatten a multilevel doubly linked list where nodes may have child pointers. Convert the hierarchy into a single-level list while maintaining order.",
    "constraints": [
      "Number of nodes <= 1000",
      "1 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5,6] with children at 3 and 5",
        "output": "[1,2,3,7,8,9,4,5,6]",
        "explanation": "Children are inserted after their parent nodes"
      }
    ],
    "hint": "Use depth-first search with stack"
  },
  {
    "id": 42,
    "title": "Data Rotator",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a data storage optimizer, rotate a linked list to the right by k places. This helps in balancing data distribution across storage nodes.",
    "constraints": [
      "Number of nodes in range [0, 500]",
      "0 <= k <= 1000"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[4,5,1,2,3]",
        "explanation": "List rotated right by 2 places"
      }
    ],
    "hint": "Connect tail to head and find new tail"
  },
  {
    "id": 43,
    "title": "Secure List Cloner",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "As a security specialist, create a deep copy of a linked list with random pointers. This helps create secure backups while maintaining all node relationships.",
    "constraints": [
      "Number of nodes in range [0, 1000]",
      "Node values are unique"
    ],
    "examples": [
      {
        "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "Deep copy with same structure",
        "explanation": "New list with identical relationships"
      }
    ],
    "hint": "Use hash map to store old node -> new node mapping"
  },
  {
    "id": 44,
    "title": "Ancient Number Triangulator",
    "topic": "Array, Two Pointers",
    "difficulty": "Medium",
    "description": "As an archaeologist, find all unique triplets in ancient number tablets that sum to zero. This helps decode numerical patterns in ancient accounting systems.",
    "constraints": [
      "3 <= nums.length <= 1000",
      "-1000 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]",
        "explanation": "Unique triplets that sum to zero"
      }
    ],
    "hint": "Sort array and use two pointers"
  },
  {
    "id": 45,
    "title": "Rainwater Harvesting Calculator",
    "topic": "Array, Two Pointers",
    "difficulty": "Hard",
    "description": "As a water resource engineer, calculate how much rainwater can be trapped between ancient temple structures given their heights. This helps in historical water management analysis.",
    "constraints": [
      "n == height.length",
      "1 <= n <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "6 units of rainwater can be trapped"
      }
    ],
    "hint": "Use two pointers or precompute left/right max arrays"
  },
  {
    "id": 46,
    "title": "Temple Scroll Duplicate Remover",
    "topic": "Array",
    "difficulty": "Easy",
    "description": "As a scribe, remove duplicates from sorted temple scrolls in-place while maintaining order. Return the number of unique entries.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order"
    ],
    "examples": [
      {
        "input": "nums = [1,1,2,2,3,4,4,5]",
        "output": "5",
        "explanation": "5 unique numbers: [1,2,3,4,5]"
      }
    ],
    "hint": "Use two pointers - reader and writer"
  },
  {
    "id": 47,
    "title": "Signal Fire Counter",
    "topic": "Array",
    "difficulty": "Easy",
    "description": "As a watchtower guard, count the maximum consecutive signal fires (1s) in a binary array. This helps determine communication range between ancient outposts.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "nums[i] is either 0 or 1"
    ],
    "examples": [
      {
        "input": "nums = [1,1,0,1,1,1,0,1,1]",
        "output": "3",
        "explanation": "Maximum consecutive 1s is 3"
      }
    ],
    "hint": "Maintain running count and max count"
  },
  {
    "id": 48,
    "title": "Ritual Scheduling Optimizer",
    "topic": "Greedy",
    "difficulty": "Easy",
    "description": "As a temple coordinator, schedule the maximum number of rituals in one room without overlapping. Each ritual has start and end times. This maximizes spiritual efficiency.",
    "constraints": [
      "1 <= N <= 10^5",
      "1 <= start[i] < end[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "N=6, start[]=[1,3,0,5,8,5], end[]=[2,4,6,7,9,9]",
        "output": "4",
        "explanation": "Maximum 4 non-overlapping rituals can be scheduled"
      }
    ],
    "hint": "Sort by end times and select non-conflicting rituals"
  },
  {
    "id": 49,
    "title": "Chariot Platform Allocator",
    "topic": "Greedy",
    "difficulty": "Medium",
    "description": "As a chariot master, find the minimum number of platforms required for a railway station so no chariot waits. Given arrival and departure times, calculate platform needs.",
    "constraints": [
      "1 <= n <= 50000",
      "0 <= arr[i] <= dep[i] <= 2359"
    ],
    "examples": [
      {
        "input": "arr[]=[900,940,950,1100,1500,1800], dep[]=[910,1200,1120,1130,1900,2000]",
        "output": "3",
        "explanation": "Minimum 3 platforms needed"
      }
    ],
    "hint": "Sort both arrays and use two pointers"
  },
  {
    "id": 50,
    "title": "Artifact Profit Maximizer",
    "topic": "Greedy",
    "difficulty": "Medium",
    "description": "As a museum curator, schedule artifact jobs with deadlines and profits to maximize total profit. Each job takes one unit of time and has a deadline.",
    "constraints": [
      "1 <= N <= 1000",
      "1 <= Deadline <= 100",
      "1 <= Profit <= 500"
    ],
    "examples": [
      {
        "input": "Jobs = [(1,4,20),(2,1,10),(3,1,40),(4,1,30)]",
        "output": "60",
        "explanation": "Jobs 1 and 3 give maximum profit"
      }
    ],
    "hint": "Sort by profit and assign to latest available slot"
  },
  {
    "id": 51,
    "title": "Expedition Pack Optimizer",
    "topic": "Greedy",
    "difficulty": "Medium",
    "description": "As an expedition planner, maximize value of items in a knapsack with fractional allowed items. This helps optimize supplies for long journeys.",
    "constraints": [
      "1 <= N <= 1000",
      "1 <= W <= 1000",
      "1 <= value[i], weight[i] <= 1000"
    ],
    "examples": [
      {
        "input": "W=50, value[]=[60,100,120], weight[]=[10,20,30]",
        "output": "240.0",
        "explanation": "Take full items of 10 and 20, fraction of 30"
      }
    ],
    "hint": "Sort by value/weight ratio in descending order"
  },
  {
    "id": 52,
    "title": "Ancient Coin Counter",
    "topic": "Greedy",
    "difficulty": "Easy",
    "description": "As a merchant, find the minimum number of ancient coins needed to make exact change. This optimizes currency transactions in historical markets.",
    "constraints": [
      "1 <= amount <= 10^4",
      "1 <= coins.length <= 12",
      "0 <= coins[i] <= 1000"
    ],
    "examples": [
      {
        "input": "coins = [1,2,5], amount = 11",
        "output": "3",
        "explanation": "11 = 5 + 5 + 1"
      }
    ],
    "hint": "Use greedy with largest denominations first"
  },
  {
    "id": 53,
    "title": "Cookie Distributor",
    "topic": "Greedy",
    "difficulty": "Easy",
    "description": "As a temple cook, assign cookies to children with greed factors. Each child gets one cookie that satisfies their greed. Maximize number of content children.",
    "constraints": [
      "1 <= children, cookies <= 10^4",
      "0 <= greed[i], size[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "greed = [1,2,3], cookies = [1,1]",
        "output": "1",
        "explanation": "Only one child can be satisfied"
      }
    ],
    "hint": "Sort both arrays and use two pointers"
  }
]